
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Area
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model Employee
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Convocation
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type Convocation = $Result.DefaultSelection<Prisma.$ConvocationPayload>
/**
 * Model ConvocationEmployee
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type ConvocationEmployee = $Result.DefaultSelection<Prisma.$ConvocationEmployeePayload>
/**
 * Model Penalty
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type Penalty = $Result.DefaultSelection<Prisma.$PenaltyPayload>
/**
 * Model Param
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type Param = $Result.DefaultSelection<Prisma.$ParamPayload>
/**
 * Model AuditLog
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Attendance
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model AttendanceRecord
 * ///////////////////////////////////////////////////
 * ///////////////////////////////////////////////////
 */
export type AttendanceRecord = $Result.DefaultSelection<Prisma.$AttendanceRecordPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.convocation`: Exposes CRUD operations for the **Convocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Convocations
    * const convocations = await prisma.convocation.findMany()
    * ```
    */
  get convocation(): Prisma.ConvocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.convocationEmployee`: Exposes CRUD operations for the **ConvocationEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConvocationEmployees
    * const convocationEmployees = await prisma.convocationEmployee.findMany()
    * ```
    */
  get convocationEmployee(): Prisma.ConvocationEmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.penalty`: Exposes CRUD operations for the **Penalty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Penalties
    * const penalties = await prisma.penalty.findMany()
    * ```
    */
  get penalty(): Prisma.PenaltyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.param`: Exposes CRUD operations for the **Param** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Params
    * const params = await prisma.param.findMany()
    * ```
    */
  get param(): Prisma.ParamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Area: 'Area',
    Employee: 'Employee',
    Convocation: 'Convocation',
    ConvocationEmployee: 'ConvocationEmployee',
    Penalty: 'Penalty',
    Param: 'Param',
    AuditLog: 'AuditLog',
    Attendance: 'Attendance',
    AttendanceRecord: 'AttendanceRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "area" | "employee" | "convocation" | "convocationEmployee" | "penalty" | "param" | "auditLog" | "attendance" | "attendanceRecord"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Convocation: {
        payload: Prisma.$ConvocationPayload<ExtArgs>
        fields: Prisma.ConvocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConvocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConvocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>
          }
          findFirst: {
            args: Prisma.ConvocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConvocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>
          }
          findMany: {
            args: Prisma.ConvocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>[]
          }
          create: {
            args: Prisma.ConvocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>
          }
          createMany: {
            args: Prisma.ConvocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConvocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>[]
          }
          delete: {
            args: Prisma.ConvocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>
          }
          update: {
            args: Prisma.ConvocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>
          }
          deleteMany: {
            args: Prisma.ConvocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConvocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConvocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>[]
          }
          upsert: {
            args: Prisma.ConvocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationPayload>
          }
          aggregate: {
            args: Prisma.ConvocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConvocation>
          }
          groupBy: {
            args: Prisma.ConvocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConvocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConvocationCountArgs<ExtArgs>
            result: $Utils.Optional<ConvocationCountAggregateOutputType> | number
          }
        }
      }
      ConvocationEmployee: {
        payload: Prisma.$ConvocationEmployeePayload<ExtArgs>
        fields: Prisma.ConvocationEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConvocationEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConvocationEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>
          }
          findFirst: {
            args: Prisma.ConvocationEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConvocationEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>
          }
          findMany: {
            args: Prisma.ConvocationEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>[]
          }
          create: {
            args: Prisma.ConvocationEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>
          }
          createMany: {
            args: Prisma.ConvocationEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConvocationEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>[]
          }
          delete: {
            args: Prisma.ConvocationEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>
          }
          update: {
            args: Prisma.ConvocationEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>
          }
          deleteMany: {
            args: Prisma.ConvocationEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConvocationEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConvocationEmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>[]
          }
          upsert: {
            args: Prisma.ConvocationEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocationEmployeePayload>
          }
          aggregate: {
            args: Prisma.ConvocationEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConvocationEmployee>
          }
          groupBy: {
            args: Prisma.ConvocationEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConvocationEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConvocationEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<ConvocationEmployeeCountAggregateOutputType> | number
          }
        }
      }
      Penalty: {
        payload: Prisma.$PenaltyPayload<ExtArgs>
        fields: Prisma.PenaltyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PenaltyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PenaltyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          findFirst: {
            args: Prisma.PenaltyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PenaltyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          findMany: {
            args: Prisma.PenaltyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          create: {
            args: Prisma.PenaltyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          createMany: {
            args: Prisma.PenaltyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PenaltyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          delete: {
            args: Prisma.PenaltyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          update: {
            args: Prisma.PenaltyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          deleteMany: {
            args: Prisma.PenaltyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PenaltyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PenaltyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>[]
          }
          upsert: {
            args: Prisma.PenaltyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenaltyPayload>
          }
          aggregate: {
            args: Prisma.PenaltyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePenalty>
          }
          groupBy: {
            args: Prisma.PenaltyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PenaltyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PenaltyCountArgs<ExtArgs>
            result: $Utils.Optional<PenaltyCountAggregateOutputType> | number
          }
        }
      }
      Param: {
        payload: Prisma.$ParamPayload<ExtArgs>
        fields: Prisma.ParamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>
          }
          findFirst: {
            args: Prisma.ParamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>
          }
          findMany: {
            args: Prisma.ParamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>[]
          }
          create: {
            args: Prisma.ParamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>
          }
          createMany: {
            args: Prisma.ParamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>[]
          }
          delete: {
            args: Prisma.ParamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>
          }
          update: {
            args: Prisma.ParamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>
          }
          deleteMany: {
            args: Prisma.ParamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>[]
          }
          upsert: {
            args: Prisma.ParamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParamPayload>
          }
          aggregate: {
            args: Prisma.ParamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParam>
          }
          groupBy: {
            args: Prisma.ParamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParamCountArgs<ExtArgs>
            result: $Utils.Optional<ParamCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: Prisma.$AttendanceRecordPayload<ExtArgs>
        fields: Prisma.AttendanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    area?: AreaOmit
    employee?: EmployeeOmit
    convocation?: ConvocationOmit
    convocationEmployee?: ConvocationEmployeeOmit
    penalty?: PenaltyOmit
    param?: ParamOmit
    auditLog?: AuditLogOmit
    attendance?: AttendanceOmit
    attendanceRecord?: AttendanceRecordOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Convocations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Convocations?: boolean | UserCountOutputTypeCountConvocationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConvocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocationWhereInput
  }


  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    Empleados: number
    ConvocationAssigned: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Empleados?: boolean | AreaCountOutputTypeCountEmpleadosArgs
    ConvocationAssigned?: boolean | AreaCountOutputTypeCountConvocationAssignedArgs
  }

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountEmpleadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountConvocationAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocationEmployeeWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    Penalties: number
    Convocations: number
    Attendance: number
    AttendanceRec: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Penalties?: boolean | EmployeeCountOutputTypeCountPenaltiesArgs
    Convocations?: boolean | EmployeeCountOutputTypeCountConvocationsArgs
    Attendance?: boolean | EmployeeCountOutputTypeCountAttendanceArgs
    AttendanceRec?: boolean | EmployeeCountOutputTypeCountAttendanceRecArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPenaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenaltyWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountConvocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocationEmployeeWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendanceRecArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }


  /**
   * Count Type ConvocationCountOutputType
   */

  export type ConvocationCountOutputType = {
    Employees: number
    Attendance: number
  }

  export type ConvocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employees?: boolean | ConvocationCountOutputTypeCountEmployeesArgs
    Attendance?: boolean | ConvocationCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * ConvocationCountOutputType without action
   */
  export type ConvocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationCountOutputType
     */
    select?: ConvocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConvocationCountOutputType without action
   */
  export type ConvocationCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocationEmployeeWhereInput
  }

  /**
   * ConvocationCountOutputType without action
   */
  export type ConvocationCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    role: string | null
    avatarPath: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    email: string | null
    role: string | null
    avatarPath: string | null
    active: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    email: number
    role: number
    avatarPath: number
    active: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    role?: true
    avatarPath?: true
    active?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    role?: true
    avatarPath?: true
    active?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    email?: true
    role?: true
    avatarPath?: true
    active?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    email: string | null
    role: string
    avatarPath: string | null
    active: boolean
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    avatarPath?: boolean
    active?: boolean
    createdAt?: boolean
    Convocations?: boolean | User$ConvocationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    avatarPath?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    avatarPath?: boolean
    active?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    avatarPath?: boolean
    active?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "email" | "role" | "avatarPath" | "active" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Convocations?: boolean | User$ConvocationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Convocations: Prisma.$ConvocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      email: string | null
      role: string
      avatarPath: string | null
      active: boolean
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Convocations<T extends User$ConvocationsArgs<ExtArgs> = {}>(args?: Subset<T, User$ConvocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly avatarPath: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Convocations
   */
  export type User$ConvocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    where?: ConvocationWhereInput
    orderBy?: ConvocationOrderByWithRelationInput | ConvocationOrderByWithRelationInput[]
    cursor?: ConvocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConvocationScalarFieldEnum | ConvocationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaAvgAggregateOutputType = {
    id: number | null
  }

  export type AreaSumAggregateOutputType = {
    id: number | null
  }

  export type AreaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    active: boolean | null
  }

  export type AreaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    active: boolean | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    active: number
    _all: number
  }


  export type AreaAvgAggregateInputType = {
    id?: true
  }

  export type AreaSumAggregateInputType = {
    id?: true
  }

  export type AreaMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    active?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    active?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    active?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _avg?: AreaAvgAggregateInputType
    _sum?: AreaSumAggregateInputType
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    active: boolean
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    active?: boolean
    Empleados?: boolean | Area$EmpleadosArgs<ExtArgs>
    ConvocationAssigned?: boolean | Area$ConvocationAssignedArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>

  export type AreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    active?: boolean
  }, ExtArgs["result"]["area"]>

  export type AreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    active?: boolean
  }, ExtArgs["result"]["area"]>

  export type AreaSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    active?: boolean
  }

  export type AreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "active", ExtArgs["result"]["area"]>
  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Empleados?: boolean | Area$EmpleadosArgs<ExtArgs>
    ConvocationAssigned?: boolean | Area$ConvocationAssignedArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      Empleados: Prisma.$EmployeePayload<ExtArgs>[]
      ConvocationAssigned: Prisma.$ConvocationEmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      active: boolean
    }, ExtArgs["result"]["area"]>
    composites: {}
  }

  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaFindUniqueArgs>(args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Area that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaFindFirstArgs>(args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaFindManyArgs>(args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
     */
    create<T extends AreaCreateArgs>(args: SelectSubset<T, AreaCreateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Areas.
     * @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaCreateManyArgs>(args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {AreaCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreaCreateManyAndReturnArgs>(args?: SelectSubset<T, AreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
     */
    delete<T extends AreaDeleteArgs>(args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaUpdateArgs>(args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaDeleteManyArgs>(args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaUpdateManyArgs>(args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas and returns the data updated in the database.
     * @param {AreaUpdateManyAndReturnArgs} args - Arguments to update many Areas.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Areas and only return the `id`
     * const areaWithIdOnly = await prisma.area.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AreaUpdateManyAndReturnArgs>(args: SelectSubset<T, AreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
     */
    upsert<T extends AreaUpsertArgs>(args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Empleados<T extends Area$EmpleadosArgs<ExtArgs> = {}>(args?: Subset<T, Area$EmpleadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConvocationAssigned<T extends Area$ConvocationAssignedArgs<ExtArgs> = {}>(args?: Subset<T, Area$ConvocationAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Area model
   */
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'Int'>
    readonly nombre: FieldRef<"Area", 'String'>
    readonly descripcion: FieldRef<"Area", 'String'>
    readonly active: FieldRef<"Area", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }

  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
  }

  /**
   * Area createManyAndReturn
   */
  export type AreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
  }

  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Area updateManyAndReturn
   */
  export type AreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }

  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
    /**
     * Limit how many Areas to delete.
     */
    limit?: number
  }

  /**
   * Area.Empleados
   */
  export type Area$EmpleadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Area.ConvocationAssigned
   */
  export type Area$ConvocationAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    where?: ConvocationEmployeeWhereInput
    orderBy?: ConvocationEmployeeOrderByWithRelationInput | ConvocationEmployeeOrderByWithRelationInput[]
    cursor?: ConvocationEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConvocationEmployeeScalarFieldEnum | ConvocationEmployeeScalarFieldEnum[]
  }

  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    areaId: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    cedula: string | null
    nombres: string | null
    apellidos: string | null
    email: string | null
    telefono: string | null
    direccion: string | null
    cargo: string | null
    fechaIngreso: Date | null
    estado: string | null
    notas: string | null
    createdAt: Date | null
    areaId: number | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    cedula: string | null
    nombres: string | null
    apellidos: string | null
    email: string | null
    telefono: string | null
    direccion: string | null
    cargo: string | null
    fechaIngreso: Date | null
    estado: string | null
    notas: string | null
    createdAt: Date | null
    areaId: number | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    cedula: number
    nombres: number
    apellidos: number
    email: number
    telefono: number
    direccion: number
    cargo: number
    fechaIngreso: number
    estado: number
    notas: number
    createdAt: number
    areaId: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    areaId?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    email?: true
    telefono?: true
    direccion?: true
    cargo?: true
    fechaIngreso?: true
    estado?: true
    notas?: true
    createdAt?: true
    areaId?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    email?: true
    telefono?: true
    direccion?: true
    cargo?: true
    fechaIngreso?: true
    estado?: true
    notas?: true
    createdAt?: true
    areaId?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    cedula?: true
    nombres?: true
    apellidos?: true
    email?: true
    telefono?: true
    direccion?: true
    cargo?: true
    fechaIngreso?: true
    estado?: true
    notas?: true
    createdAt?: true
    areaId?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    cedula: string
    nombres: string
    apellidos: string
    email: string | null
    telefono: string | null
    direccion: string | null
    cargo: string | null
    fechaIngreso: Date | null
    estado: string
    notas: string | null
    createdAt: Date
    areaId: number
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cedula?: boolean
    nombres?: boolean
    apellidos?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    cargo?: boolean
    fechaIngreso?: boolean
    estado?: boolean
    notas?: boolean
    createdAt?: boolean
    areaId?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    Penalties?: boolean | Employee$PenaltiesArgs<ExtArgs>
    Convocations?: boolean | Employee$ConvocationsArgs<ExtArgs>
    Attendance?: boolean | Employee$AttendanceArgs<ExtArgs>
    AttendanceRec?: boolean | Employee$AttendanceRecArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cedula?: boolean
    nombres?: boolean
    apellidos?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    cargo?: boolean
    fechaIngreso?: boolean
    estado?: boolean
    notas?: boolean
    createdAt?: boolean
    areaId?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cedula?: boolean
    nombres?: boolean
    apellidos?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    cargo?: boolean
    fechaIngreso?: boolean
    estado?: boolean
    notas?: boolean
    createdAt?: boolean
    areaId?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    cedula?: boolean
    nombres?: boolean
    apellidos?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    cargo?: boolean
    fechaIngreso?: boolean
    estado?: boolean
    notas?: boolean
    createdAt?: boolean
    areaId?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cedula" | "nombres" | "apellidos" | "email" | "telefono" | "direccion" | "cargo" | "fechaIngreso" | "estado" | "notas" | "createdAt" | "areaId", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    Penalties?: boolean | Employee$PenaltiesArgs<ExtArgs>
    Convocations?: boolean | Employee$ConvocationsArgs<ExtArgs>
    Attendance?: boolean | Employee$AttendanceArgs<ExtArgs>
    AttendanceRec?: boolean | Employee$AttendanceRecArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      area: Prisma.$AreaPayload<ExtArgs>
      Penalties: Prisma.$PenaltyPayload<ExtArgs>[]
      Convocations: Prisma.$ConvocationEmployeePayload<ExtArgs>[]
      Attendance: Prisma.$AttendancePayload<ExtArgs>[]
      AttendanceRec: Prisma.$AttendanceRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cedula: string
      nombres: string
      apellidos: string
      email: string | null
      telefono: string | null
      direccion: string | null
      cargo: string | null
      fechaIngreso: Date | null
      estado: string
      notas: string | null
      createdAt: Date
      areaId: number
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Penalties<T extends Employee$PenaltiesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$PenaltiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Convocations<T extends Employee$ConvocationsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$ConvocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Attendance<T extends Employee$AttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Employee$AttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AttendanceRec<T extends Employee$AttendanceRecArgs<ExtArgs> = {}>(args?: Subset<T, Employee$AttendanceRecArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly cedula: FieldRef<"Employee", 'String'>
    readonly nombres: FieldRef<"Employee", 'String'>
    readonly apellidos: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly telefono: FieldRef<"Employee", 'String'>
    readonly direccion: FieldRef<"Employee", 'String'>
    readonly cargo: FieldRef<"Employee", 'String'>
    readonly fechaIngreso: FieldRef<"Employee", 'DateTime'>
    readonly estado: FieldRef<"Employee", 'String'>
    readonly notas: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly areaId: FieldRef<"Employee", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.Penalties
   */
  export type Employee$PenaltiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    where?: PenaltyWhereInput
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    cursor?: PenaltyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Employee.Convocations
   */
  export type Employee$ConvocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    where?: ConvocationEmployeeWhereInput
    orderBy?: ConvocationEmployeeOrderByWithRelationInput | ConvocationEmployeeOrderByWithRelationInput[]
    cursor?: ConvocationEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConvocationEmployeeScalarFieldEnum | ConvocationEmployeeScalarFieldEnum[]
  }

  /**
   * Employee.Attendance
   */
  export type Employee$AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Employee.AttendanceRec
   */
  export type Employee$AttendanceRecArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Convocation
   */

  export type AggregateConvocation = {
    _count: ConvocationCountAggregateOutputType | null
    _avg: ConvocationAvgAggregateOutputType | null
    _sum: ConvocationSumAggregateOutputType | null
    _min: ConvocationMinAggregateOutputType | null
    _max: ConvocationMaxAggregateOutputType | null
  }

  export type ConvocationAvgAggregateOutputType = {
    id: number | null
    creadoPorId: number | null
  }

  export type ConvocationSumAggregateOutputType = {
    id: number | null
    creadoPorId: number | null
  }

  export type ConvocationMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    descripcion: string | null
    fechaTrabajo: Date | null
    estado: string | null
    creadoPorId: number | null
    createdAt: Date | null
  }

  export type ConvocationMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    descripcion: string | null
    fechaTrabajo: Date | null
    estado: string | null
    creadoPorId: number | null
    createdAt: Date | null
  }

  export type ConvocationCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    fechaTrabajo: number
    estado: number
    creadoPorId: number
    createdAt: number
    _all: number
  }


  export type ConvocationAvgAggregateInputType = {
    id?: true
    creadoPorId?: true
  }

  export type ConvocationSumAggregateInputType = {
    id?: true
    creadoPorId?: true
  }

  export type ConvocationMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaTrabajo?: true
    estado?: true
    creadoPorId?: true
    createdAt?: true
  }

  export type ConvocationMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaTrabajo?: true
    estado?: true
    creadoPorId?: true
    createdAt?: true
  }

  export type ConvocationCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaTrabajo?: true
    estado?: true
    creadoPorId?: true
    createdAt?: true
    _all?: true
  }

  export type ConvocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Convocation to aggregate.
     */
    where?: ConvocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocations to fetch.
     */
    orderBy?: ConvocationOrderByWithRelationInput | ConvocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConvocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Convocations
    **/
    _count?: true | ConvocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConvocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConvocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConvocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConvocationMaxAggregateInputType
  }

  export type GetConvocationAggregateType<T extends ConvocationAggregateArgs> = {
        [P in keyof T & keyof AggregateConvocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConvocation[P]>
      : GetScalarType<T[P], AggregateConvocation[P]>
  }




  export type ConvocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocationWhereInput
    orderBy?: ConvocationOrderByWithAggregationInput | ConvocationOrderByWithAggregationInput[]
    by: ConvocationScalarFieldEnum[] | ConvocationScalarFieldEnum
    having?: ConvocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConvocationCountAggregateInputType | true
    _avg?: ConvocationAvgAggregateInputType
    _sum?: ConvocationSumAggregateInputType
    _min?: ConvocationMinAggregateInputType
    _max?: ConvocationMaxAggregateInputType
  }

  export type ConvocationGroupByOutputType = {
    id: number
    titulo: string
    descripcion: string | null
    fechaTrabajo: Date
    estado: string
    creadoPorId: number
    createdAt: Date
    _count: ConvocationCountAggregateOutputType | null
    _avg: ConvocationAvgAggregateOutputType | null
    _sum: ConvocationSumAggregateOutputType | null
    _min: ConvocationMinAggregateOutputType | null
    _max: ConvocationMaxAggregateOutputType | null
  }

  type GetConvocationGroupByPayload<T extends ConvocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConvocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConvocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConvocationGroupByOutputType[P]>
            : GetScalarType<T[P], ConvocationGroupByOutputType[P]>
        }
      >
    >


  export type ConvocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaTrabajo?: boolean
    estado?: boolean
    creadoPorId?: boolean
    createdAt?: boolean
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
    Employees?: boolean | Convocation$EmployeesArgs<ExtArgs>
    Attendance?: boolean | Convocation$AttendanceArgs<ExtArgs>
    _count?: boolean | ConvocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["convocation"]>

  export type ConvocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaTrabajo?: boolean
    estado?: boolean
    creadoPorId?: boolean
    createdAt?: boolean
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["convocation"]>

  export type ConvocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaTrabajo?: boolean
    estado?: boolean
    creadoPorId?: boolean
    createdAt?: boolean
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["convocation"]>

  export type ConvocationSelectScalar = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaTrabajo?: boolean
    estado?: boolean
    creadoPorId?: boolean
    createdAt?: boolean
  }

  export type ConvocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "descripcion" | "fechaTrabajo" | "estado" | "creadoPorId" | "createdAt", ExtArgs["result"]["convocation"]>
  export type ConvocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
    Employees?: boolean | Convocation$EmployeesArgs<ExtArgs>
    Attendance?: boolean | Convocation$AttendanceArgs<ExtArgs>
    _count?: boolean | ConvocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConvocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConvocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creadoPor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConvocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Convocation"
    objects: {
      creadoPor: Prisma.$UserPayload<ExtArgs>
      Employees: Prisma.$ConvocationEmployeePayload<ExtArgs>[]
      Attendance: Prisma.$AttendanceRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      descripcion: string | null
      fechaTrabajo: Date
      estado: string
      creadoPorId: number
      createdAt: Date
    }, ExtArgs["result"]["convocation"]>
    composites: {}
  }

  type ConvocationGetPayload<S extends boolean | null | undefined | ConvocationDefaultArgs> = $Result.GetResult<Prisma.$ConvocationPayload, S>

  type ConvocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConvocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConvocationCountAggregateInputType | true
    }

  export interface ConvocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Convocation'], meta: { name: 'Convocation' } }
    /**
     * Find zero or one Convocation that matches the filter.
     * @param {ConvocationFindUniqueArgs} args - Arguments to find a Convocation
     * @example
     * // Get one Convocation
     * const convocation = await prisma.convocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConvocationFindUniqueArgs>(args: SelectSubset<T, ConvocationFindUniqueArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Convocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConvocationFindUniqueOrThrowArgs} args - Arguments to find a Convocation
     * @example
     * // Get one Convocation
     * const convocation = await prisma.convocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConvocationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConvocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Convocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationFindFirstArgs} args - Arguments to find a Convocation
     * @example
     * // Get one Convocation
     * const convocation = await prisma.convocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConvocationFindFirstArgs>(args?: SelectSubset<T, ConvocationFindFirstArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Convocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationFindFirstOrThrowArgs} args - Arguments to find a Convocation
     * @example
     * // Get one Convocation
     * const convocation = await prisma.convocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConvocationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConvocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Convocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Convocations
     * const convocations = await prisma.convocation.findMany()
     * 
     * // Get first 10 Convocations
     * const convocations = await prisma.convocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const convocationWithIdOnly = await prisma.convocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConvocationFindManyArgs>(args?: SelectSubset<T, ConvocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Convocation.
     * @param {ConvocationCreateArgs} args - Arguments to create a Convocation.
     * @example
     * // Create one Convocation
     * const Convocation = await prisma.convocation.create({
     *   data: {
     *     // ... data to create a Convocation
     *   }
     * })
     * 
     */
    create<T extends ConvocationCreateArgs>(args: SelectSubset<T, ConvocationCreateArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Convocations.
     * @param {ConvocationCreateManyArgs} args - Arguments to create many Convocations.
     * @example
     * // Create many Convocations
     * const convocation = await prisma.convocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConvocationCreateManyArgs>(args?: SelectSubset<T, ConvocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Convocations and returns the data saved in the database.
     * @param {ConvocationCreateManyAndReturnArgs} args - Arguments to create many Convocations.
     * @example
     * // Create many Convocations
     * const convocation = await prisma.convocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Convocations and only return the `id`
     * const convocationWithIdOnly = await prisma.convocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConvocationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConvocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Convocation.
     * @param {ConvocationDeleteArgs} args - Arguments to delete one Convocation.
     * @example
     * // Delete one Convocation
     * const Convocation = await prisma.convocation.delete({
     *   where: {
     *     // ... filter to delete one Convocation
     *   }
     * })
     * 
     */
    delete<T extends ConvocationDeleteArgs>(args: SelectSubset<T, ConvocationDeleteArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Convocation.
     * @param {ConvocationUpdateArgs} args - Arguments to update one Convocation.
     * @example
     * // Update one Convocation
     * const convocation = await prisma.convocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConvocationUpdateArgs>(args: SelectSubset<T, ConvocationUpdateArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Convocations.
     * @param {ConvocationDeleteManyArgs} args - Arguments to filter Convocations to delete.
     * @example
     * // Delete a few Convocations
     * const { count } = await prisma.convocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConvocationDeleteManyArgs>(args?: SelectSubset<T, ConvocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Convocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Convocations
     * const convocation = await prisma.convocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConvocationUpdateManyArgs>(args: SelectSubset<T, ConvocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Convocations and returns the data updated in the database.
     * @param {ConvocationUpdateManyAndReturnArgs} args - Arguments to update many Convocations.
     * @example
     * // Update many Convocations
     * const convocation = await prisma.convocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Convocations and only return the `id`
     * const convocationWithIdOnly = await prisma.convocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConvocationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConvocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Convocation.
     * @param {ConvocationUpsertArgs} args - Arguments to update or create a Convocation.
     * @example
     * // Update or create a Convocation
     * const convocation = await prisma.convocation.upsert({
     *   create: {
     *     // ... data to create a Convocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Convocation we want to update
     *   }
     * })
     */
    upsert<T extends ConvocationUpsertArgs>(args: SelectSubset<T, ConvocationUpsertArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Convocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationCountArgs} args - Arguments to filter Convocations to count.
     * @example
     * // Count the number of Convocations
     * const count = await prisma.convocation.count({
     *   where: {
     *     // ... the filter for the Convocations we want to count
     *   }
     * })
    **/
    count<T extends ConvocationCountArgs>(
      args?: Subset<T, ConvocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConvocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Convocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConvocationAggregateArgs>(args: Subset<T, ConvocationAggregateArgs>): Prisma.PrismaPromise<GetConvocationAggregateType<T>>

    /**
     * Group by Convocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConvocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConvocationGroupByArgs['orderBy'] }
        : { orderBy?: ConvocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConvocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConvocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Convocation model
   */
  readonly fields: ConvocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Convocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConvocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creadoPor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Employees<T extends Convocation$EmployeesArgs<ExtArgs> = {}>(args?: Subset<T, Convocation$EmployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Attendance<T extends Convocation$AttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Convocation$AttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Convocation model
   */
  interface ConvocationFieldRefs {
    readonly id: FieldRef<"Convocation", 'Int'>
    readonly titulo: FieldRef<"Convocation", 'String'>
    readonly descripcion: FieldRef<"Convocation", 'String'>
    readonly fechaTrabajo: FieldRef<"Convocation", 'DateTime'>
    readonly estado: FieldRef<"Convocation", 'String'>
    readonly creadoPorId: FieldRef<"Convocation", 'Int'>
    readonly createdAt: FieldRef<"Convocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Convocation findUnique
   */
  export type ConvocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * Filter, which Convocation to fetch.
     */
    where: ConvocationWhereUniqueInput
  }

  /**
   * Convocation findUniqueOrThrow
   */
  export type ConvocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * Filter, which Convocation to fetch.
     */
    where: ConvocationWhereUniqueInput
  }

  /**
   * Convocation findFirst
   */
  export type ConvocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * Filter, which Convocation to fetch.
     */
    where?: ConvocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocations to fetch.
     */
    orderBy?: ConvocationOrderByWithRelationInput | ConvocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Convocations.
     */
    cursor?: ConvocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Convocations.
     */
    distinct?: ConvocationScalarFieldEnum | ConvocationScalarFieldEnum[]
  }

  /**
   * Convocation findFirstOrThrow
   */
  export type ConvocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * Filter, which Convocation to fetch.
     */
    where?: ConvocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocations to fetch.
     */
    orderBy?: ConvocationOrderByWithRelationInput | ConvocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Convocations.
     */
    cursor?: ConvocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Convocations.
     */
    distinct?: ConvocationScalarFieldEnum | ConvocationScalarFieldEnum[]
  }

  /**
   * Convocation findMany
   */
  export type ConvocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * Filter, which Convocations to fetch.
     */
    where?: ConvocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocations to fetch.
     */
    orderBy?: ConvocationOrderByWithRelationInput | ConvocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Convocations.
     */
    cursor?: ConvocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocations.
     */
    skip?: number
    distinct?: ConvocationScalarFieldEnum | ConvocationScalarFieldEnum[]
  }

  /**
   * Convocation create
   */
  export type ConvocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Convocation.
     */
    data: XOR<ConvocationCreateInput, ConvocationUncheckedCreateInput>
  }

  /**
   * Convocation createMany
   */
  export type ConvocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Convocations.
     */
    data: ConvocationCreateManyInput | ConvocationCreateManyInput[]
  }

  /**
   * Convocation createManyAndReturn
   */
  export type ConvocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * The data used to create many Convocations.
     */
    data: ConvocationCreateManyInput | ConvocationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Convocation update
   */
  export type ConvocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Convocation.
     */
    data: XOR<ConvocationUpdateInput, ConvocationUncheckedUpdateInput>
    /**
     * Choose, which Convocation to update.
     */
    where: ConvocationWhereUniqueInput
  }

  /**
   * Convocation updateMany
   */
  export type ConvocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Convocations.
     */
    data: XOR<ConvocationUpdateManyMutationInput, ConvocationUncheckedUpdateManyInput>
    /**
     * Filter which Convocations to update
     */
    where?: ConvocationWhereInput
    /**
     * Limit how many Convocations to update.
     */
    limit?: number
  }

  /**
   * Convocation updateManyAndReturn
   */
  export type ConvocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * The data used to update Convocations.
     */
    data: XOR<ConvocationUpdateManyMutationInput, ConvocationUncheckedUpdateManyInput>
    /**
     * Filter which Convocations to update
     */
    where?: ConvocationWhereInput
    /**
     * Limit how many Convocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Convocation upsert
   */
  export type ConvocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Convocation to update in case it exists.
     */
    where: ConvocationWhereUniqueInput
    /**
     * In case the Convocation found by the `where` argument doesn't exist, create a new Convocation with this data.
     */
    create: XOR<ConvocationCreateInput, ConvocationUncheckedCreateInput>
    /**
     * In case the Convocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConvocationUpdateInput, ConvocationUncheckedUpdateInput>
  }

  /**
   * Convocation delete
   */
  export type ConvocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
    /**
     * Filter which Convocation to delete.
     */
    where: ConvocationWhereUniqueInput
  }

  /**
   * Convocation deleteMany
   */
  export type ConvocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Convocations to delete
     */
    where?: ConvocationWhereInput
    /**
     * Limit how many Convocations to delete.
     */
    limit?: number
  }

  /**
   * Convocation.Employees
   */
  export type Convocation$EmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    where?: ConvocationEmployeeWhereInput
    orderBy?: ConvocationEmployeeOrderByWithRelationInput | ConvocationEmployeeOrderByWithRelationInput[]
    cursor?: ConvocationEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConvocationEmployeeScalarFieldEnum | ConvocationEmployeeScalarFieldEnum[]
  }

  /**
   * Convocation.Attendance
   */
  export type Convocation$AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Convocation without action
   */
  export type ConvocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocation
     */
    select?: ConvocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Convocation
     */
    omit?: ConvocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationInclude<ExtArgs> | null
  }


  /**
   * Model ConvocationEmployee
   */

  export type AggregateConvocationEmployee = {
    _count: ConvocationEmployeeCountAggregateOutputType | null
    _avg: ConvocationEmployeeAvgAggregateOutputType | null
    _sum: ConvocationEmployeeSumAggregateOutputType | null
    _min: ConvocationEmployeeMinAggregateOutputType | null
    _max: ConvocationEmployeeMaxAggregateOutputType | null
  }

  export type ConvocationEmployeeAvgAggregateOutputType = {
    id: number | null
    convocationId: number | null
    employeeId: number | null
    assignedAreaId: number | null
  }

  export type ConvocationEmployeeSumAggregateOutputType = {
    id: number | null
    convocationId: number | null
    employeeId: number | null
    assignedAreaId: number | null
  }

  export type ConvocationEmployeeMinAggregateOutputType = {
    id: number | null
    convocationId: number | null
    employeeId: number | null
    estado: string | null
    comentario: string | null
    assignedAreaId: number | null
    updatedAt: Date | null
  }

  export type ConvocationEmployeeMaxAggregateOutputType = {
    id: number | null
    convocationId: number | null
    employeeId: number | null
    estado: string | null
    comentario: string | null
    assignedAreaId: number | null
    updatedAt: Date | null
  }

  export type ConvocationEmployeeCountAggregateOutputType = {
    id: number
    convocationId: number
    employeeId: number
    estado: number
    comentario: number
    assignedAreaId: number
    updatedAt: number
    _all: number
  }


  export type ConvocationEmployeeAvgAggregateInputType = {
    id?: true
    convocationId?: true
    employeeId?: true
    assignedAreaId?: true
  }

  export type ConvocationEmployeeSumAggregateInputType = {
    id?: true
    convocationId?: true
    employeeId?: true
    assignedAreaId?: true
  }

  export type ConvocationEmployeeMinAggregateInputType = {
    id?: true
    convocationId?: true
    employeeId?: true
    estado?: true
    comentario?: true
    assignedAreaId?: true
    updatedAt?: true
  }

  export type ConvocationEmployeeMaxAggregateInputType = {
    id?: true
    convocationId?: true
    employeeId?: true
    estado?: true
    comentario?: true
    assignedAreaId?: true
    updatedAt?: true
  }

  export type ConvocationEmployeeCountAggregateInputType = {
    id?: true
    convocationId?: true
    employeeId?: true
    estado?: true
    comentario?: true
    assignedAreaId?: true
    updatedAt?: true
    _all?: true
  }

  export type ConvocationEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConvocationEmployee to aggregate.
     */
    where?: ConvocationEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConvocationEmployees to fetch.
     */
    orderBy?: ConvocationEmployeeOrderByWithRelationInput | ConvocationEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConvocationEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConvocationEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConvocationEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConvocationEmployees
    **/
    _count?: true | ConvocationEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConvocationEmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConvocationEmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConvocationEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConvocationEmployeeMaxAggregateInputType
  }

  export type GetConvocationEmployeeAggregateType<T extends ConvocationEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateConvocationEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConvocationEmployee[P]>
      : GetScalarType<T[P], AggregateConvocationEmployee[P]>
  }




  export type ConvocationEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocationEmployeeWhereInput
    orderBy?: ConvocationEmployeeOrderByWithAggregationInput | ConvocationEmployeeOrderByWithAggregationInput[]
    by: ConvocationEmployeeScalarFieldEnum[] | ConvocationEmployeeScalarFieldEnum
    having?: ConvocationEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConvocationEmployeeCountAggregateInputType | true
    _avg?: ConvocationEmployeeAvgAggregateInputType
    _sum?: ConvocationEmployeeSumAggregateInputType
    _min?: ConvocationEmployeeMinAggregateInputType
    _max?: ConvocationEmployeeMaxAggregateInputType
  }

  export type ConvocationEmployeeGroupByOutputType = {
    id: number
    convocationId: number
    employeeId: number
    estado: string
    comentario: string | null
    assignedAreaId: number | null
    updatedAt: Date
    _count: ConvocationEmployeeCountAggregateOutputType | null
    _avg: ConvocationEmployeeAvgAggregateOutputType | null
    _sum: ConvocationEmployeeSumAggregateOutputType | null
    _min: ConvocationEmployeeMinAggregateOutputType | null
    _max: ConvocationEmployeeMaxAggregateOutputType | null
  }

  type GetConvocationEmployeeGroupByPayload<T extends ConvocationEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConvocationEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConvocationEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConvocationEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], ConvocationEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type ConvocationEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    convocationId?: boolean
    employeeId?: boolean
    estado?: boolean
    comentario?: boolean
    assignedAreaId?: boolean
    updatedAt?: boolean
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedArea?: boolean | ConvocationEmployee$assignedAreaArgs<ExtArgs>
  }, ExtArgs["result"]["convocationEmployee"]>

  export type ConvocationEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    convocationId?: boolean
    employeeId?: boolean
    estado?: boolean
    comentario?: boolean
    assignedAreaId?: boolean
    updatedAt?: boolean
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedArea?: boolean | ConvocationEmployee$assignedAreaArgs<ExtArgs>
  }, ExtArgs["result"]["convocationEmployee"]>

  export type ConvocationEmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    convocationId?: boolean
    employeeId?: boolean
    estado?: boolean
    comentario?: boolean
    assignedAreaId?: boolean
    updatedAt?: boolean
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedArea?: boolean | ConvocationEmployee$assignedAreaArgs<ExtArgs>
  }, ExtArgs["result"]["convocationEmployee"]>

  export type ConvocationEmployeeSelectScalar = {
    id?: boolean
    convocationId?: boolean
    employeeId?: boolean
    estado?: boolean
    comentario?: boolean
    assignedAreaId?: boolean
    updatedAt?: boolean
  }

  export type ConvocationEmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "convocationId" | "employeeId" | "estado" | "comentario" | "assignedAreaId" | "updatedAt", ExtArgs["result"]["convocationEmployee"]>
  export type ConvocationEmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedArea?: boolean | ConvocationEmployee$assignedAreaArgs<ExtArgs>
  }
  export type ConvocationEmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedArea?: boolean | ConvocationEmployee$assignedAreaArgs<ExtArgs>
  }
  export type ConvocationEmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    assignedArea?: boolean | ConvocationEmployee$assignedAreaArgs<ExtArgs>
  }

  export type $ConvocationEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConvocationEmployee"
    objects: {
      convocation: Prisma.$ConvocationPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      assignedArea: Prisma.$AreaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      convocationId: number
      employeeId: number
      estado: string
      comentario: string | null
      assignedAreaId: number | null
      updatedAt: Date
    }, ExtArgs["result"]["convocationEmployee"]>
    composites: {}
  }

  type ConvocationEmployeeGetPayload<S extends boolean | null | undefined | ConvocationEmployeeDefaultArgs> = $Result.GetResult<Prisma.$ConvocationEmployeePayload, S>

  type ConvocationEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConvocationEmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConvocationEmployeeCountAggregateInputType | true
    }

  export interface ConvocationEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConvocationEmployee'], meta: { name: 'ConvocationEmployee' } }
    /**
     * Find zero or one ConvocationEmployee that matches the filter.
     * @param {ConvocationEmployeeFindUniqueArgs} args - Arguments to find a ConvocationEmployee
     * @example
     * // Get one ConvocationEmployee
     * const convocationEmployee = await prisma.convocationEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConvocationEmployeeFindUniqueArgs>(args: SelectSubset<T, ConvocationEmployeeFindUniqueArgs<ExtArgs>>): Prisma__ConvocationEmployeeClient<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConvocationEmployee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConvocationEmployeeFindUniqueOrThrowArgs} args - Arguments to find a ConvocationEmployee
     * @example
     * // Get one ConvocationEmployee
     * const convocationEmployee = await prisma.convocationEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConvocationEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, ConvocationEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConvocationEmployeeClient<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConvocationEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationEmployeeFindFirstArgs} args - Arguments to find a ConvocationEmployee
     * @example
     * // Get one ConvocationEmployee
     * const convocationEmployee = await prisma.convocationEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConvocationEmployeeFindFirstArgs>(args?: SelectSubset<T, ConvocationEmployeeFindFirstArgs<ExtArgs>>): Prisma__ConvocationEmployeeClient<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConvocationEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationEmployeeFindFirstOrThrowArgs} args - Arguments to find a ConvocationEmployee
     * @example
     * // Get one ConvocationEmployee
     * const convocationEmployee = await prisma.convocationEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConvocationEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, ConvocationEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConvocationEmployeeClient<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConvocationEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConvocationEmployees
     * const convocationEmployees = await prisma.convocationEmployee.findMany()
     * 
     * // Get first 10 ConvocationEmployees
     * const convocationEmployees = await prisma.convocationEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const convocationEmployeeWithIdOnly = await prisma.convocationEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConvocationEmployeeFindManyArgs>(args?: SelectSubset<T, ConvocationEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConvocationEmployee.
     * @param {ConvocationEmployeeCreateArgs} args - Arguments to create a ConvocationEmployee.
     * @example
     * // Create one ConvocationEmployee
     * const ConvocationEmployee = await prisma.convocationEmployee.create({
     *   data: {
     *     // ... data to create a ConvocationEmployee
     *   }
     * })
     * 
     */
    create<T extends ConvocationEmployeeCreateArgs>(args: SelectSubset<T, ConvocationEmployeeCreateArgs<ExtArgs>>): Prisma__ConvocationEmployeeClient<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConvocationEmployees.
     * @param {ConvocationEmployeeCreateManyArgs} args - Arguments to create many ConvocationEmployees.
     * @example
     * // Create many ConvocationEmployees
     * const convocationEmployee = await prisma.convocationEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConvocationEmployeeCreateManyArgs>(args?: SelectSubset<T, ConvocationEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConvocationEmployees and returns the data saved in the database.
     * @param {ConvocationEmployeeCreateManyAndReturnArgs} args - Arguments to create many ConvocationEmployees.
     * @example
     * // Create many ConvocationEmployees
     * const convocationEmployee = await prisma.convocationEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConvocationEmployees and only return the `id`
     * const convocationEmployeeWithIdOnly = await prisma.convocationEmployee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConvocationEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, ConvocationEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConvocationEmployee.
     * @param {ConvocationEmployeeDeleteArgs} args - Arguments to delete one ConvocationEmployee.
     * @example
     * // Delete one ConvocationEmployee
     * const ConvocationEmployee = await prisma.convocationEmployee.delete({
     *   where: {
     *     // ... filter to delete one ConvocationEmployee
     *   }
     * })
     * 
     */
    delete<T extends ConvocationEmployeeDeleteArgs>(args: SelectSubset<T, ConvocationEmployeeDeleteArgs<ExtArgs>>): Prisma__ConvocationEmployeeClient<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConvocationEmployee.
     * @param {ConvocationEmployeeUpdateArgs} args - Arguments to update one ConvocationEmployee.
     * @example
     * // Update one ConvocationEmployee
     * const convocationEmployee = await prisma.convocationEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConvocationEmployeeUpdateArgs>(args: SelectSubset<T, ConvocationEmployeeUpdateArgs<ExtArgs>>): Prisma__ConvocationEmployeeClient<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConvocationEmployees.
     * @param {ConvocationEmployeeDeleteManyArgs} args - Arguments to filter ConvocationEmployees to delete.
     * @example
     * // Delete a few ConvocationEmployees
     * const { count } = await prisma.convocationEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConvocationEmployeeDeleteManyArgs>(args?: SelectSubset<T, ConvocationEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConvocationEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConvocationEmployees
     * const convocationEmployee = await prisma.convocationEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConvocationEmployeeUpdateManyArgs>(args: SelectSubset<T, ConvocationEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConvocationEmployees and returns the data updated in the database.
     * @param {ConvocationEmployeeUpdateManyAndReturnArgs} args - Arguments to update many ConvocationEmployees.
     * @example
     * // Update many ConvocationEmployees
     * const convocationEmployee = await prisma.convocationEmployee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConvocationEmployees and only return the `id`
     * const convocationEmployeeWithIdOnly = await prisma.convocationEmployee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConvocationEmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, ConvocationEmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConvocationEmployee.
     * @param {ConvocationEmployeeUpsertArgs} args - Arguments to update or create a ConvocationEmployee.
     * @example
     * // Update or create a ConvocationEmployee
     * const convocationEmployee = await prisma.convocationEmployee.upsert({
     *   create: {
     *     // ... data to create a ConvocationEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConvocationEmployee we want to update
     *   }
     * })
     */
    upsert<T extends ConvocationEmployeeUpsertArgs>(args: SelectSubset<T, ConvocationEmployeeUpsertArgs<ExtArgs>>): Prisma__ConvocationEmployeeClient<$Result.GetResult<Prisma.$ConvocationEmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConvocationEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationEmployeeCountArgs} args - Arguments to filter ConvocationEmployees to count.
     * @example
     * // Count the number of ConvocationEmployees
     * const count = await prisma.convocationEmployee.count({
     *   where: {
     *     // ... the filter for the ConvocationEmployees we want to count
     *   }
     * })
    **/
    count<T extends ConvocationEmployeeCountArgs>(
      args?: Subset<T, ConvocationEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConvocationEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConvocationEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConvocationEmployeeAggregateArgs>(args: Subset<T, ConvocationEmployeeAggregateArgs>): Prisma.PrismaPromise<GetConvocationEmployeeAggregateType<T>>

    /**
     * Group by ConvocationEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocationEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConvocationEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConvocationEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: ConvocationEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConvocationEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConvocationEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConvocationEmployee model
   */
  readonly fields: ConvocationEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConvocationEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConvocationEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    convocation<T extends ConvocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConvocationDefaultArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedArea<T extends ConvocationEmployee$assignedAreaArgs<ExtArgs> = {}>(args?: Subset<T, ConvocationEmployee$assignedAreaArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConvocationEmployee model
   */
  interface ConvocationEmployeeFieldRefs {
    readonly id: FieldRef<"ConvocationEmployee", 'Int'>
    readonly convocationId: FieldRef<"ConvocationEmployee", 'Int'>
    readonly employeeId: FieldRef<"ConvocationEmployee", 'Int'>
    readonly estado: FieldRef<"ConvocationEmployee", 'String'>
    readonly comentario: FieldRef<"ConvocationEmployee", 'String'>
    readonly assignedAreaId: FieldRef<"ConvocationEmployee", 'Int'>
    readonly updatedAt: FieldRef<"ConvocationEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConvocationEmployee findUnique
   */
  export type ConvocationEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ConvocationEmployee to fetch.
     */
    where: ConvocationEmployeeWhereUniqueInput
  }

  /**
   * ConvocationEmployee findUniqueOrThrow
   */
  export type ConvocationEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ConvocationEmployee to fetch.
     */
    where: ConvocationEmployeeWhereUniqueInput
  }

  /**
   * ConvocationEmployee findFirst
   */
  export type ConvocationEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ConvocationEmployee to fetch.
     */
    where?: ConvocationEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConvocationEmployees to fetch.
     */
    orderBy?: ConvocationEmployeeOrderByWithRelationInput | ConvocationEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConvocationEmployees.
     */
    cursor?: ConvocationEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConvocationEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConvocationEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConvocationEmployees.
     */
    distinct?: ConvocationEmployeeScalarFieldEnum | ConvocationEmployeeScalarFieldEnum[]
  }

  /**
   * ConvocationEmployee findFirstOrThrow
   */
  export type ConvocationEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ConvocationEmployee to fetch.
     */
    where?: ConvocationEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConvocationEmployees to fetch.
     */
    orderBy?: ConvocationEmployeeOrderByWithRelationInput | ConvocationEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConvocationEmployees.
     */
    cursor?: ConvocationEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConvocationEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConvocationEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConvocationEmployees.
     */
    distinct?: ConvocationEmployeeScalarFieldEnum | ConvocationEmployeeScalarFieldEnum[]
  }

  /**
   * ConvocationEmployee findMany
   */
  export type ConvocationEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ConvocationEmployees to fetch.
     */
    where?: ConvocationEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConvocationEmployees to fetch.
     */
    orderBy?: ConvocationEmployeeOrderByWithRelationInput | ConvocationEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConvocationEmployees.
     */
    cursor?: ConvocationEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConvocationEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConvocationEmployees.
     */
    skip?: number
    distinct?: ConvocationEmployeeScalarFieldEnum | ConvocationEmployeeScalarFieldEnum[]
  }

  /**
   * ConvocationEmployee create
   */
  export type ConvocationEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a ConvocationEmployee.
     */
    data: XOR<ConvocationEmployeeCreateInput, ConvocationEmployeeUncheckedCreateInput>
  }

  /**
   * ConvocationEmployee createMany
   */
  export type ConvocationEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConvocationEmployees.
     */
    data: ConvocationEmployeeCreateManyInput | ConvocationEmployeeCreateManyInput[]
  }

  /**
   * ConvocationEmployee createManyAndReturn
   */
  export type ConvocationEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many ConvocationEmployees.
     */
    data: ConvocationEmployeeCreateManyInput | ConvocationEmployeeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConvocationEmployee update
   */
  export type ConvocationEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a ConvocationEmployee.
     */
    data: XOR<ConvocationEmployeeUpdateInput, ConvocationEmployeeUncheckedUpdateInput>
    /**
     * Choose, which ConvocationEmployee to update.
     */
    where: ConvocationEmployeeWhereUniqueInput
  }

  /**
   * ConvocationEmployee updateMany
   */
  export type ConvocationEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConvocationEmployees.
     */
    data: XOR<ConvocationEmployeeUpdateManyMutationInput, ConvocationEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which ConvocationEmployees to update
     */
    where?: ConvocationEmployeeWhereInput
    /**
     * Limit how many ConvocationEmployees to update.
     */
    limit?: number
  }

  /**
   * ConvocationEmployee updateManyAndReturn
   */
  export type ConvocationEmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * The data used to update ConvocationEmployees.
     */
    data: XOR<ConvocationEmployeeUpdateManyMutationInput, ConvocationEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which ConvocationEmployees to update
     */
    where?: ConvocationEmployeeWhereInput
    /**
     * Limit how many ConvocationEmployees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConvocationEmployee upsert
   */
  export type ConvocationEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the ConvocationEmployee to update in case it exists.
     */
    where: ConvocationEmployeeWhereUniqueInput
    /**
     * In case the ConvocationEmployee found by the `where` argument doesn't exist, create a new ConvocationEmployee with this data.
     */
    create: XOR<ConvocationEmployeeCreateInput, ConvocationEmployeeUncheckedCreateInput>
    /**
     * In case the ConvocationEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConvocationEmployeeUpdateInput, ConvocationEmployeeUncheckedUpdateInput>
  }

  /**
   * ConvocationEmployee delete
   */
  export type ConvocationEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
    /**
     * Filter which ConvocationEmployee to delete.
     */
    where: ConvocationEmployeeWhereUniqueInput
  }

  /**
   * ConvocationEmployee deleteMany
   */
  export type ConvocationEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConvocationEmployees to delete
     */
    where?: ConvocationEmployeeWhereInput
    /**
     * Limit how many ConvocationEmployees to delete.
     */
    limit?: number
  }

  /**
   * ConvocationEmployee.assignedArea
   */
  export type ConvocationEmployee$assignedAreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Area
     */
    omit?: AreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
  }

  /**
   * ConvocationEmployee without action
   */
  export type ConvocationEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConvocationEmployee
     */
    select?: ConvocationEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConvocationEmployee
     */
    omit?: ConvocationEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConvocationEmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Penalty
   */

  export type AggregatePenalty = {
    _count: PenaltyCountAggregateOutputType | null
    _avg: PenaltyAvgAggregateOutputType | null
    _sum: PenaltySumAggregateOutputType | null
    _min: PenaltyMinAggregateOutputType | null
    _max: PenaltyMaxAggregateOutputType | null
  }

  export type PenaltyAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    registradoPor: number | null
  }

  export type PenaltySumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    registradoPor: number | null
  }

  export type PenaltyMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    motivo: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    origen: string | null
    activo: boolean | null
    registradoPor: number | null
    createdAt: Date | null
  }

  export type PenaltyMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    motivo: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    origen: string | null
    activo: boolean | null
    registradoPor: number | null
    createdAt: Date | null
  }

  export type PenaltyCountAggregateOutputType = {
    id: number
    employeeId: number
    motivo: number
    fechaInicio: number
    fechaFin: number
    origen: number
    activo: number
    registradoPor: number
    createdAt: number
    _all: number
  }


  export type PenaltyAvgAggregateInputType = {
    id?: true
    employeeId?: true
    registradoPor?: true
  }

  export type PenaltySumAggregateInputType = {
    id?: true
    employeeId?: true
    registradoPor?: true
  }

  export type PenaltyMinAggregateInputType = {
    id?: true
    employeeId?: true
    motivo?: true
    fechaInicio?: true
    fechaFin?: true
    origen?: true
    activo?: true
    registradoPor?: true
    createdAt?: true
  }

  export type PenaltyMaxAggregateInputType = {
    id?: true
    employeeId?: true
    motivo?: true
    fechaInicio?: true
    fechaFin?: true
    origen?: true
    activo?: true
    registradoPor?: true
    createdAt?: true
  }

  export type PenaltyCountAggregateInputType = {
    id?: true
    employeeId?: true
    motivo?: true
    fechaInicio?: true
    fechaFin?: true
    origen?: true
    activo?: true
    registradoPor?: true
    createdAt?: true
    _all?: true
  }

  export type PenaltyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penalty to aggregate.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Penalties
    **/
    _count?: true | PenaltyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PenaltyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PenaltySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PenaltyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PenaltyMaxAggregateInputType
  }

  export type GetPenaltyAggregateType<T extends PenaltyAggregateArgs> = {
        [P in keyof T & keyof AggregatePenalty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePenalty[P]>
      : GetScalarType<T[P], AggregatePenalty[P]>
  }




  export type PenaltyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenaltyWhereInput
    orderBy?: PenaltyOrderByWithAggregationInput | PenaltyOrderByWithAggregationInput[]
    by: PenaltyScalarFieldEnum[] | PenaltyScalarFieldEnum
    having?: PenaltyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PenaltyCountAggregateInputType | true
    _avg?: PenaltyAvgAggregateInputType
    _sum?: PenaltySumAggregateInputType
    _min?: PenaltyMinAggregateInputType
    _max?: PenaltyMaxAggregateInputType
  }

  export type PenaltyGroupByOutputType = {
    id: number
    employeeId: number
    motivo: string
    fechaInicio: Date
    fechaFin: Date
    origen: string
    activo: boolean
    registradoPor: number | null
    createdAt: Date
    _count: PenaltyCountAggregateOutputType | null
    _avg: PenaltyAvgAggregateOutputType | null
    _sum: PenaltySumAggregateOutputType | null
    _min: PenaltyMinAggregateOutputType | null
    _max: PenaltyMaxAggregateOutputType | null
  }

  type GetPenaltyGroupByPayload<T extends PenaltyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PenaltyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PenaltyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PenaltyGroupByOutputType[P]>
            : GetScalarType<T[P], PenaltyGroupByOutputType[P]>
        }
      >
    >


  export type PenaltySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    motivo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    origen?: boolean
    activo?: boolean
    registradoPor?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    motivo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    origen?: boolean
    activo?: boolean
    registradoPor?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    motivo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    origen?: boolean
    activo?: boolean
    registradoPor?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["penalty"]>

  export type PenaltySelectScalar = {
    id?: boolean
    employeeId?: boolean
    motivo?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    origen?: boolean
    activo?: boolean
    registradoPor?: boolean
    createdAt?: boolean
  }

  export type PenaltyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "motivo" | "fechaInicio" | "fechaFin" | "origen" | "activo" | "registradoPor" | "createdAt", ExtArgs["result"]["penalty"]>
  export type PenaltyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PenaltyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PenaltyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PenaltyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Penalty"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      motivo: string
      fechaInicio: Date
      fechaFin: Date
      origen: string
      activo: boolean
      registradoPor: number | null
      createdAt: Date
    }, ExtArgs["result"]["penalty"]>
    composites: {}
  }

  type PenaltyGetPayload<S extends boolean | null | undefined | PenaltyDefaultArgs> = $Result.GetResult<Prisma.$PenaltyPayload, S>

  type PenaltyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PenaltyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PenaltyCountAggregateInputType | true
    }

  export interface PenaltyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Penalty'], meta: { name: 'Penalty' } }
    /**
     * Find zero or one Penalty that matches the filter.
     * @param {PenaltyFindUniqueArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PenaltyFindUniqueArgs>(args: SelectSubset<T, PenaltyFindUniqueArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Penalty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PenaltyFindUniqueOrThrowArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PenaltyFindUniqueOrThrowArgs>(args: SelectSubset<T, PenaltyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Penalty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindFirstArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PenaltyFindFirstArgs>(args?: SelectSubset<T, PenaltyFindFirstArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Penalty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindFirstOrThrowArgs} args - Arguments to find a Penalty
     * @example
     * // Get one Penalty
     * const penalty = await prisma.penalty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PenaltyFindFirstOrThrowArgs>(args?: SelectSubset<T, PenaltyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Penalties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Penalties
     * const penalties = await prisma.penalty.findMany()
     * 
     * // Get first 10 Penalties
     * const penalties = await prisma.penalty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const penaltyWithIdOnly = await prisma.penalty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PenaltyFindManyArgs>(args?: SelectSubset<T, PenaltyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Penalty.
     * @param {PenaltyCreateArgs} args - Arguments to create a Penalty.
     * @example
     * // Create one Penalty
     * const Penalty = await prisma.penalty.create({
     *   data: {
     *     // ... data to create a Penalty
     *   }
     * })
     * 
     */
    create<T extends PenaltyCreateArgs>(args: SelectSubset<T, PenaltyCreateArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Penalties.
     * @param {PenaltyCreateManyArgs} args - Arguments to create many Penalties.
     * @example
     * // Create many Penalties
     * const penalty = await prisma.penalty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PenaltyCreateManyArgs>(args?: SelectSubset<T, PenaltyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Penalties and returns the data saved in the database.
     * @param {PenaltyCreateManyAndReturnArgs} args - Arguments to create many Penalties.
     * @example
     * // Create many Penalties
     * const penalty = await prisma.penalty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Penalties and only return the `id`
     * const penaltyWithIdOnly = await prisma.penalty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PenaltyCreateManyAndReturnArgs>(args?: SelectSubset<T, PenaltyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Penalty.
     * @param {PenaltyDeleteArgs} args - Arguments to delete one Penalty.
     * @example
     * // Delete one Penalty
     * const Penalty = await prisma.penalty.delete({
     *   where: {
     *     // ... filter to delete one Penalty
     *   }
     * })
     * 
     */
    delete<T extends PenaltyDeleteArgs>(args: SelectSubset<T, PenaltyDeleteArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Penalty.
     * @param {PenaltyUpdateArgs} args - Arguments to update one Penalty.
     * @example
     * // Update one Penalty
     * const penalty = await prisma.penalty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PenaltyUpdateArgs>(args: SelectSubset<T, PenaltyUpdateArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Penalties.
     * @param {PenaltyDeleteManyArgs} args - Arguments to filter Penalties to delete.
     * @example
     * // Delete a few Penalties
     * const { count } = await prisma.penalty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PenaltyDeleteManyArgs>(args?: SelectSubset<T, PenaltyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Penalties
     * const penalty = await prisma.penalty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PenaltyUpdateManyArgs>(args: SelectSubset<T, PenaltyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penalties and returns the data updated in the database.
     * @param {PenaltyUpdateManyAndReturnArgs} args - Arguments to update many Penalties.
     * @example
     * // Update many Penalties
     * const penalty = await prisma.penalty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Penalties and only return the `id`
     * const penaltyWithIdOnly = await prisma.penalty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PenaltyUpdateManyAndReturnArgs>(args: SelectSubset<T, PenaltyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Penalty.
     * @param {PenaltyUpsertArgs} args - Arguments to update or create a Penalty.
     * @example
     * // Update or create a Penalty
     * const penalty = await prisma.penalty.upsert({
     *   create: {
     *     // ... data to create a Penalty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Penalty we want to update
     *   }
     * })
     */
    upsert<T extends PenaltyUpsertArgs>(args: SelectSubset<T, PenaltyUpsertArgs<ExtArgs>>): Prisma__PenaltyClient<$Result.GetResult<Prisma.$PenaltyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Penalties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyCountArgs} args - Arguments to filter Penalties to count.
     * @example
     * // Count the number of Penalties
     * const count = await prisma.penalty.count({
     *   where: {
     *     // ... the filter for the Penalties we want to count
     *   }
     * })
    **/
    count<T extends PenaltyCountArgs>(
      args?: Subset<T, PenaltyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PenaltyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Penalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PenaltyAggregateArgs>(args: Subset<T, PenaltyAggregateArgs>): Prisma.PrismaPromise<GetPenaltyAggregateType<T>>

    /**
     * Group by Penalty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenaltyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PenaltyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PenaltyGroupByArgs['orderBy'] }
        : { orderBy?: PenaltyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PenaltyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPenaltyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Penalty model
   */
  readonly fields: PenaltyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Penalty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PenaltyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Penalty model
   */
  interface PenaltyFieldRefs {
    readonly id: FieldRef<"Penalty", 'Int'>
    readonly employeeId: FieldRef<"Penalty", 'Int'>
    readonly motivo: FieldRef<"Penalty", 'String'>
    readonly fechaInicio: FieldRef<"Penalty", 'DateTime'>
    readonly fechaFin: FieldRef<"Penalty", 'DateTime'>
    readonly origen: FieldRef<"Penalty", 'String'>
    readonly activo: FieldRef<"Penalty", 'Boolean'>
    readonly registradoPor: FieldRef<"Penalty", 'Int'>
    readonly createdAt: FieldRef<"Penalty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Penalty findUnique
   */
  export type PenaltyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty findUniqueOrThrow
   */
  export type PenaltyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty findFirst
   */
  export type PenaltyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penalties.
     */
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty findFirstOrThrow
   */
  export type PenaltyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalty to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penalties.
     */
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty findMany
   */
  export type PenaltyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter, which Penalties to fetch.
     */
    where?: PenaltyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penalties to fetch.
     */
    orderBy?: PenaltyOrderByWithRelationInput | PenaltyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Penalties.
     */
    cursor?: PenaltyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penalties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penalties.
     */
    skip?: number
    distinct?: PenaltyScalarFieldEnum | PenaltyScalarFieldEnum[]
  }

  /**
   * Penalty create
   */
  export type PenaltyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The data needed to create a Penalty.
     */
    data: XOR<PenaltyCreateInput, PenaltyUncheckedCreateInput>
  }

  /**
   * Penalty createMany
   */
  export type PenaltyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Penalties.
     */
    data: PenaltyCreateManyInput | PenaltyCreateManyInput[]
  }

  /**
   * Penalty createManyAndReturn
   */
  export type PenaltyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * The data used to create many Penalties.
     */
    data: PenaltyCreateManyInput | PenaltyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Penalty update
   */
  export type PenaltyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The data needed to update a Penalty.
     */
    data: XOR<PenaltyUpdateInput, PenaltyUncheckedUpdateInput>
    /**
     * Choose, which Penalty to update.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty updateMany
   */
  export type PenaltyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Penalties.
     */
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyInput>
    /**
     * Filter which Penalties to update
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to update.
     */
    limit?: number
  }

  /**
   * Penalty updateManyAndReturn
   */
  export type PenaltyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * The data used to update Penalties.
     */
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyInput>
    /**
     * Filter which Penalties to update
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Penalty upsert
   */
  export type PenaltyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * The filter to search for the Penalty to update in case it exists.
     */
    where: PenaltyWhereUniqueInput
    /**
     * In case the Penalty found by the `where` argument doesn't exist, create a new Penalty with this data.
     */
    create: XOR<PenaltyCreateInput, PenaltyUncheckedCreateInput>
    /**
     * In case the Penalty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PenaltyUpdateInput, PenaltyUncheckedUpdateInput>
  }

  /**
   * Penalty delete
   */
  export type PenaltyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
    /**
     * Filter which Penalty to delete.
     */
    where: PenaltyWhereUniqueInput
  }

  /**
   * Penalty deleteMany
   */
  export type PenaltyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penalties to delete
     */
    where?: PenaltyWhereInput
    /**
     * Limit how many Penalties to delete.
     */
    limit?: number
  }

  /**
   * Penalty without action
   */
  export type PenaltyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Penalty
     */
    select?: PenaltySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Penalty
     */
    omit?: PenaltyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenaltyInclude<ExtArgs> | null
  }


  /**
   * Model Param
   */

  export type AggregateParam = {
    _count: ParamCountAggregateOutputType | null
    _min: ParamMinAggregateOutputType | null
    _max: ParamMaxAggregateOutputType | null
  }

  export type ParamMinAggregateOutputType = {
    clave: string | null
    valor: string | null
  }

  export type ParamMaxAggregateOutputType = {
    clave: string | null
    valor: string | null
  }

  export type ParamCountAggregateOutputType = {
    clave: number
    valor: number
    _all: number
  }


  export type ParamMinAggregateInputType = {
    clave?: true
    valor?: true
  }

  export type ParamMaxAggregateInputType = {
    clave?: true
    valor?: true
  }

  export type ParamCountAggregateInputType = {
    clave?: true
    valor?: true
    _all?: true
  }

  export type ParamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Param to aggregate.
     */
    where?: ParamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Params to fetch.
     */
    orderBy?: ParamOrderByWithRelationInput | ParamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Params
    **/
    _count?: true | ParamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParamMaxAggregateInputType
  }

  export type GetParamAggregateType<T extends ParamAggregateArgs> = {
        [P in keyof T & keyof AggregateParam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParam[P]>
      : GetScalarType<T[P], AggregateParam[P]>
  }




  export type ParamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParamWhereInput
    orderBy?: ParamOrderByWithAggregationInput | ParamOrderByWithAggregationInput[]
    by: ParamScalarFieldEnum[] | ParamScalarFieldEnum
    having?: ParamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParamCountAggregateInputType | true
    _min?: ParamMinAggregateInputType
    _max?: ParamMaxAggregateInputType
  }

  export type ParamGroupByOutputType = {
    clave: string
    valor: string
    _count: ParamCountAggregateOutputType | null
    _min: ParamMinAggregateOutputType | null
    _max: ParamMaxAggregateOutputType | null
  }

  type GetParamGroupByPayload<T extends ParamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParamGroupByOutputType[P]>
            : GetScalarType<T[P], ParamGroupByOutputType[P]>
        }
      >
    >


  export type ParamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clave?: boolean
    valor?: boolean
  }, ExtArgs["result"]["param"]>

  export type ParamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clave?: boolean
    valor?: boolean
  }, ExtArgs["result"]["param"]>

  export type ParamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clave?: boolean
    valor?: boolean
  }, ExtArgs["result"]["param"]>

  export type ParamSelectScalar = {
    clave?: boolean
    valor?: boolean
  }

  export type ParamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"clave" | "valor", ExtArgs["result"]["param"]>

  export type $ParamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Param"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      clave: string
      valor: string
    }, ExtArgs["result"]["param"]>
    composites: {}
  }

  type ParamGetPayload<S extends boolean | null | undefined | ParamDefaultArgs> = $Result.GetResult<Prisma.$ParamPayload, S>

  type ParamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParamCountAggregateInputType | true
    }

  export interface ParamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Param'], meta: { name: 'Param' } }
    /**
     * Find zero or one Param that matches the filter.
     * @param {ParamFindUniqueArgs} args - Arguments to find a Param
     * @example
     * // Get one Param
     * const param = await prisma.param.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParamFindUniqueArgs>(args: SelectSubset<T, ParamFindUniqueArgs<ExtArgs>>): Prisma__ParamClient<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Param that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParamFindUniqueOrThrowArgs} args - Arguments to find a Param
     * @example
     * // Get one Param
     * const param = await prisma.param.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParamFindUniqueOrThrowArgs>(args: SelectSubset<T, ParamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParamClient<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Param that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParamFindFirstArgs} args - Arguments to find a Param
     * @example
     * // Get one Param
     * const param = await prisma.param.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParamFindFirstArgs>(args?: SelectSubset<T, ParamFindFirstArgs<ExtArgs>>): Prisma__ParamClient<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Param that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParamFindFirstOrThrowArgs} args - Arguments to find a Param
     * @example
     * // Get one Param
     * const param = await prisma.param.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParamFindFirstOrThrowArgs>(args?: SelectSubset<T, ParamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParamClient<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Params that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Params
     * const params = await prisma.param.findMany()
     * 
     * // Get first 10 Params
     * const params = await prisma.param.findMany({ take: 10 })
     * 
     * // Only select the `clave`
     * const paramWithClaveOnly = await prisma.param.findMany({ select: { clave: true } })
     * 
     */
    findMany<T extends ParamFindManyArgs>(args?: SelectSubset<T, ParamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Param.
     * @param {ParamCreateArgs} args - Arguments to create a Param.
     * @example
     * // Create one Param
     * const Param = await prisma.param.create({
     *   data: {
     *     // ... data to create a Param
     *   }
     * })
     * 
     */
    create<T extends ParamCreateArgs>(args: SelectSubset<T, ParamCreateArgs<ExtArgs>>): Prisma__ParamClient<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Params.
     * @param {ParamCreateManyArgs} args - Arguments to create many Params.
     * @example
     * // Create many Params
     * const param = await prisma.param.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParamCreateManyArgs>(args?: SelectSubset<T, ParamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Params and returns the data saved in the database.
     * @param {ParamCreateManyAndReturnArgs} args - Arguments to create many Params.
     * @example
     * // Create many Params
     * const param = await prisma.param.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Params and only return the `clave`
     * const paramWithClaveOnly = await prisma.param.createManyAndReturn({
     *   select: { clave: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParamCreateManyAndReturnArgs>(args?: SelectSubset<T, ParamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Param.
     * @param {ParamDeleteArgs} args - Arguments to delete one Param.
     * @example
     * // Delete one Param
     * const Param = await prisma.param.delete({
     *   where: {
     *     // ... filter to delete one Param
     *   }
     * })
     * 
     */
    delete<T extends ParamDeleteArgs>(args: SelectSubset<T, ParamDeleteArgs<ExtArgs>>): Prisma__ParamClient<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Param.
     * @param {ParamUpdateArgs} args - Arguments to update one Param.
     * @example
     * // Update one Param
     * const param = await prisma.param.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParamUpdateArgs>(args: SelectSubset<T, ParamUpdateArgs<ExtArgs>>): Prisma__ParamClient<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Params.
     * @param {ParamDeleteManyArgs} args - Arguments to filter Params to delete.
     * @example
     * // Delete a few Params
     * const { count } = await prisma.param.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParamDeleteManyArgs>(args?: SelectSubset<T, ParamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Params.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Params
     * const param = await prisma.param.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParamUpdateManyArgs>(args: SelectSubset<T, ParamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Params and returns the data updated in the database.
     * @param {ParamUpdateManyAndReturnArgs} args - Arguments to update many Params.
     * @example
     * // Update many Params
     * const param = await prisma.param.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Params and only return the `clave`
     * const paramWithClaveOnly = await prisma.param.updateManyAndReturn({
     *   select: { clave: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParamUpdateManyAndReturnArgs>(args: SelectSubset<T, ParamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Param.
     * @param {ParamUpsertArgs} args - Arguments to update or create a Param.
     * @example
     * // Update or create a Param
     * const param = await prisma.param.upsert({
     *   create: {
     *     // ... data to create a Param
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Param we want to update
     *   }
     * })
     */
    upsert<T extends ParamUpsertArgs>(args: SelectSubset<T, ParamUpsertArgs<ExtArgs>>): Prisma__ParamClient<$Result.GetResult<Prisma.$ParamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Params.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParamCountArgs} args - Arguments to filter Params to count.
     * @example
     * // Count the number of Params
     * const count = await prisma.param.count({
     *   where: {
     *     // ... the filter for the Params we want to count
     *   }
     * })
    **/
    count<T extends ParamCountArgs>(
      args?: Subset<T, ParamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Param.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParamAggregateArgs>(args: Subset<T, ParamAggregateArgs>): Prisma.PrismaPromise<GetParamAggregateType<T>>

    /**
     * Group by Param.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParamGroupByArgs['orderBy'] }
        : { orderBy?: ParamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Param model
   */
  readonly fields: ParamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Param.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Param model
   */
  interface ParamFieldRefs {
    readonly clave: FieldRef<"Param", 'String'>
    readonly valor: FieldRef<"Param", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Param findUnique
   */
  export type ParamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * Filter, which Param to fetch.
     */
    where: ParamWhereUniqueInput
  }

  /**
   * Param findUniqueOrThrow
   */
  export type ParamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * Filter, which Param to fetch.
     */
    where: ParamWhereUniqueInput
  }

  /**
   * Param findFirst
   */
  export type ParamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * Filter, which Param to fetch.
     */
    where?: ParamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Params to fetch.
     */
    orderBy?: ParamOrderByWithRelationInput | ParamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Params.
     */
    cursor?: ParamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Params.
     */
    distinct?: ParamScalarFieldEnum | ParamScalarFieldEnum[]
  }

  /**
   * Param findFirstOrThrow
   */
  export type ParamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * Filter, which Param to fetch.
     */
    where?: ParamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Params to fetch.
     */
    orderBy?: ParamOrderByWithRelationInput | ParamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Params.
     */
    cursor?: ParamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Params.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Params.
     */
    distinct?: ParamScalarFieldEnum | ParamScalarFieldEnum[]
  }

  /**
   * Param findMany
   */
  export type ParamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * Filter, which Params to fetch.
     */
    where?: ParamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Params to fetch.
     */
    orderBy?: ParamOrderByWithRelationInput | ParamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Params.
     */
    cursor?: ParamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Params from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Params.
     */
    skip?: number
    distinct?: ParamScalarFieldEnum | ParamScalarFieldEnum[]
  }

  /**
   * Param create
   */
  export type ParamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * The data needed to create a Param.
     */
    data: XOR<ParamCreateInput, ParamUncheckedCreateInput>
  }

  /**
   * Param createMany
   */
  export type ParamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Params.
     */
    data: ParamCreateManyInput | ParamCreateManyInput[]
  }

  /**
   * Param createManyAndReturn
   */
  export type ParamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * The data used to create many Params.
     */
    data: ParamCreateManyInput | ParamCreateManyInput[]
  }

  /**
   * Param update
   */
  export type ParamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * The data needed to update a Param.
     */
    data: XOR<ParamUpdateInput, ParamUncheckedUpdateInput>
    /**
     * Choose, which Param to update.
     */
    where: ParamWhereUniqueInput
  }

  /**
   * Param updateMany
   */
  export type ParamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Params.
     */
    data: XOR<ParamUpdateManyMutationInput, ParamUncheckedUpdateManyInput>
    /**
     * Filter which Params to update
     */
    where?: ParamWhereInput
    /**
     * Limit how many Params to update.
     */
    limit?: number
  }

  /**
   * Param updateManyAndReturn
   */
  export type ParamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * The data used to update Params.
     */
    data: XOR<ParamUpdateManyMutationInput, ParamUncheckedUpdateManyInput>
    /**
     * Filter which Params to update
     */
    where?: ParamWhereInput
    /**
     * Limit how many Params to update.
     */
    limit?: number
  }

  /**
   * Param upsert
   */
  export type ParamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * The filter to search for the Param to update in case it exists.
     */
    where: ParamWhereUniqueInput
    /**
     * In case the Param found by the `where` argument doesn't exist, create a new Param with this data.
     */
    create: XOR<ParamCreateInput, ParamUncheckedCreateInput>
    /**
     * In case the Param was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParamUpdateInput, ParamUncheckedUpdateInput>
  }

  /**
   * Param delete
   */
  export type ParamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
    /**
     * Filter which Param to delete.
     */
    where: ParamWhereUniqueInput
  }

  /**
   * Param deleteMany
   */
  export type ParamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Params to delete
     */
    where?: ParamWhereInput
    /**
     * Limit how many Params to delete.
     */
    limit?: number
  }

  /**
   * Param without action
   */
  export type ParamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Param
     */
    select?: ParamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Param
     */
    omit?: ParamOmit<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    actorUserId: number | null
    entidadId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    actorUserId: number | null
    entidadId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    actorUserId: number | null
    accion: string | null
    entidad: string | null
    entidadId: number | null
    payloadJson: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    actorUserId: number | null
    accion: string | null
    entidad: string | null
    entidadId: number | null
    payloadJson: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorUserId: number
    accion: number
    entidad: number
    entidadId: number
    payloadJson: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    actorUserId?: true
    entidadId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    actorUserId?: true
    entidadId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    actorUserId?: true
    accion?: true
    entidad?: true
    entidadId?: true
    payloadJson?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorUserId?: true
    accion?: true
    entidad?: true
    entidadId?: true
    payloadJson?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorUserId?: true
    accion?: true
    entidad?: true
    entidadId?: true
    payloadJson?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    actorUserId: number | null
    accion: string
    entidad: string
    entidadId: number | null
    payloadJson: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorUserId?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    payloadJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorUserId?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    payloadJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorUserId?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    payloadJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorUserId?: boolean
    accion?: boolean
    entidad?: boolean
    entidadId?: boolean
    payloadJson?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorUserId" | "accion" | "entidad" | "entidadId" | "payloadJson" | "createdAt", ExtArgs["result"]["auditLog"]>

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actorUserId: number | null
      accion: string
      entidad: string
      entidadId: number | null
      payloadJson: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly actorUserId: FieldRef<"AuditLog", 'Int'>
    readonly accion: FieldRef<"AuditLog", 'String'>
    readonly entidad: FieldRef<"AuditLog", 'String'>
    readonly entidadId: FieldRef<"AuditLog", 'Int'>
    readonly payloadJson: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    fecha: Date | null
    horaEntrada: Date | null
    horaSalida: Date | null
    createdAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    fecha: Date | null
    horaEntrada: Date | null
    horaSalida: Date | null
    createdAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    employeeId: number
    fecha: number
    horaEntrada: number
    horaSalida: number
    createdAt: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type AttendanceSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    fecha?: true
    horaEntrada?: true
    horaSalida?: true
    createdAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    fecha?: true
    horaEntrada?: true
    horaSalida?: true
    createdAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    fecha?: true
    horaEntrada?: true
    horaSalida?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: number
    employeeId: number
    fecha: Date
    horaEntrada: Date | null
    horaSalida: Date | null
    createdAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    fecha?: boolean
    horaEntrada?: boolean
    horaSalida?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    fecha?: boolean
    horaEntrada?: boolean
    horaSalida?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    fecha?: boolean
    horaEntrada?: boolean
    horaSalida?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    fecha?: boolean
    horaEntrada?: boolean
    horaSalida?: boolean
    createdAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "fecha" | "horaEntrada" | "horaSalida" | "createdAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      fecha: Date
      horaEntrada: Date | null
      horaSalida: Date | null
      createdAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'Int'>
    readonly employeeId: FieldRef<"Attendance", 'Int'>
    readonly fecha: FieldRef<"Attendance", 'DateTime'>
    readonly horaEntrada: FieldRef<"Attendance", 'DateTime'>
    readonly horaSalida: FieldRef<"Attendance", 'DateTime'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceRecord
   */

  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    convocationId: number | null
  }

  export type AttendanceRecordSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    convocationId: number | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    convocationId: number | null
    fecha: Date | null
    horaEntrada: Date | null
    horaSalida: Date | null
    estado: string | null
    comentario: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    convocationId: number | null
    fecha: Date | null
    horaEntrada: Date | null
    horaSalida: Date | null
    estado: string | null
    comentario: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    employeeId: number
    convocationId: number
    fecha: number
    horaEntrada: number
    horaSalida: number
    estado: number
    comentario: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceRecordAvgAggregateInputType = {
    id?: true
    employeeId?: true
    convocationId?: true
  }

  export type AttendanceRecordSumAggregateInputType = {
    id?: true
    employeeId?: true
    convocationId?: true
  }

  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    employeeId?: true
    convocationId?: true
    fecha?: true
    horaEntrada?: true
    horaSalida?: true
    estado?: true
    comentario?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    employeeId?: true
    convocationId?: true
    fecha?: true
    horaEntrada?: true
    horaSalida?: true
    estado?: true
    comentario?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    employeeId?: true
    convocationId?: true
    fecha?: true
    horaEntrada?: true
    horaSalida?: true
    estado?: true
    comentario?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithAggregationInput | AttendanceRecordOrderByWithAggregationInput[]
    by: AttendanceRecordScalarFieldEnum[] | AttendanceRecordScalarFieldEnum
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _avg?: AttendanceRecordAvgAggregateInputType
    _sum?: AttendanceRecordSumAggregateInputType
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type AttendanceRecordGroupByOutputType = {
    id: number
    employeeId: number
    convocationId: number
    fecha: Date
    horaEntrada: Date | null
    horaSalida: Date | null
    estado: string
    comentario: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    convocationId?: boolean
    fecha?: boolean
    horaEntrada?: boolean
    horaSalida?: boolean
    estado?: boolean
    comentario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    convocationId?: boolean
    fecha?: boolean
    horaEntrada?: boolean
    horaSalida?: boolean
    estado?: boolean
    comentario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    convocationId?: boolean
    fecha?: boolean
    horaEntrada?: boolean
    horaSalida?: boolean
    estado?: boolean
    comentario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectScalar = {
    id?: boolean
    employeeId?: boolean
    convocationId?: boolean
    fecha?: boolean
    horaEntrada?: boolean
    horaSalida?: boolean
    estado?: boolean
    comentario?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "convocationId" | "fecha" | "horaEntrada" | "horaSalida" | "estado" | "comentario" | "createdAt" | "updatedAt", ExtArgs["result"]["attendanceRecord"]>
  export type AttendanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    convocation?: boolean | ConvocationDefaultArgs<ExtArgs>
  }

  export type $AttendanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceRecord"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      convocation: Prisma.$ConvocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      convocationId: number
      fecha: Date
      horaEntrada: Date | null
      horaSalida: Date | null
      estado: string
      comentario: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceRecord"]>
    composites: {}
  }

  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordDefaultArgs> = $Result.GetResult<Prisma.$AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceRecordFindUniqueArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceRecordFindFirstArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceRecordFindManyArgs>(args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
     */
    create<T extends AttendanceRecordCreateArgs>(args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceRecords.
     * @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceRecordCreateManyArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceRecords and returns the data saved in the database.
     * @param {AttendanceRecordCreateManyAndReturnArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
     */
    delete<T extends AttendanceRecordDeleteArgs>(args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceRecordUpdateArgs>(args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceRecordDeleteManyArgs>(args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceRecordUpdateManyArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords and returns the data updated in the database.
     * @param {AttendanceRecordUpdateManyAndReturnArgs} args - Arguments to update many AttendanceRecords.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceRecordUpsertArgs>(args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceRecord model
   */
  readonly fields: AttendanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    convocation<T extends ConvocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConvocationDefaultArgs<ExtArgs>>): Prisma__ConvocationClient<$Result.GetResult<Prisma.$ConvocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceRecord model
   */
  interface AttendanceRecordFieldRefs {
    readonly id: FieldRef<"AttendanceRecord", 'Int'>
    readonly employeeId: FieldRef<"AttendanceRecord", 'Int'>
    readonly convocationId: FieldRef<"AttendanceRecord", 'Int'>
    readonly fecha: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly horaEntrada: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly horaSalida: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly estado: FieldRef<"AttendanceRecord", 'String'>
    readonly comentario: FieldRef<"AttendanceRecord", 'String'>
    readonly createdAt: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceRecord findUnique
   */
  export type AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findFirst
   */
  export type AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }

  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
  }

  /**
   * AttendanceRecord createManyAndReturn
   */
  export type AttendanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
  }

  /**
   * AttendanceRecord updateManyAndReturn
   */
  export type AttendanceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }

  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to delete.
     */
    limit?: number
  }

  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    email: 'email',
    role: 'role',
    avatarPath: 'avatarPath',
    active: 'active',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    active: 'active'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    cedula: 'cedula',
    nombres: 'nombres',
    apellidos: 'apellidos',
    email: 'email',
    telefono: 'telefono',
    direccion: 'direccion',
    cargo: 'cargo',
    fechaIngreso: 'fechaIngreso',
    estado: 'estado',
    notas: 'notas',
    createdAt: 'createdAt',
    areaId: 'areaId'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ConvocationScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    fechaTrabajo: 'fechaTrabajo',
    estado: 'estado',
    creadoPorId: 'creadoPorId',
    createdAt: 'createdAt'
  };

  export type ConvocationScalarFieldEnum = (typeof ConvocationScalarFieldEnum)[keyof typeof ConvocationScalarFieldEnum]


  export const ConvocationEmployeeScalarFieldEnum: {
    id: 'id',
    convocationId: 'convocationId',
    employeeId: 'employeeId',
    estado: 'estado',
    comentario: 'comentario',
    assignedAreaId: 'assignedAreaId',
    updatedAt: 'updatedAt'
  };

  export type ConvocationEmployeeScalarFieldEnum = (typeof ConvocationEmployeeScalarFieldEnum)[keyof typeof ConvocationEmployeeScalarFieldEnum]


  export const PenaltyScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    motivo: 'motivo',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    origen: 'origen',
    activo: 'activo',
    registradoPor: 'registradoPor',
    createdAt: 'createdAt'
  };

  export type PenaltyScalarFieldEnum = (typeof PenaltyScalarFieldEnum)[keyof typeof PenaltyScalarFieldEnum]


  export const ParamScalarFieldEnum: {
    clave: 'clave',
    valor: 'valor'
  };

  export type ParamScalarFieldEnum = (typeof ParamScalarFieldEnum)[keyof typeof ParamScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorUserId: 'actorUserId',
    accion: 'accion',
    entidad: 'entidad',
    entidadId: 'entidadId',
    payloadJson: 'payloadJson',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    fecha: 'fecha',
    horaEntrada: 'horaEntrada',
    horaSalida: 'horaSalida',
    createdAt: 'createdAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    convocationId: 'convocationId',
    fecha: 'fecha',
    horaEntrada: 'horaEntrada',
    horaSalida: 'horaSalida',
    estado: 'estado',
    comentario: 'comentario',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    avatarPath?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    Convocations?: ConvocationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    Convocations?: ConvocationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    avatarPath?: StringNullableFilter<"User"> | string | null
    active?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    Convocations?: ConvocationListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    avatarPath?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    avatarPath?: StringNullableWithAggregatesFilter<"User"> | string | null
    active?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: IntFilter<"Area"> | number
    nombre?: StringFilter<"Area"> | string
    descripcion?: StringNullableFilter<"Area"> | string | null
    active?: BoolFilter<"Area"> | boolean
    Empleados?: EmployeeListRelationFilter
    ConvocationAssigned?: ConvocationEmployeeListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    active?: SortOrder
    Empleados?: EmployeeOrderByRelationAggregateInput
    ConvocationAssigned?: ConvocationEmployeeOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    nombre?: StringFilter<"Area"> | string
    descripcion?: StringNullableFilter<"Area"> | string | null
    active?: BoolFilter<"Area"> | boolean
    Empleados?: EmployeeListRelationFilter
    ConvocationAssigned?: ConvocationEmployeeListRelationFilter
  }, "id">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    active?: SortOrder
    _count?: AreaCountOrderByAggregateInput
    _avg?: AreaAvgOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
    _sum?: AreaSumOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Area"> | number
    nombre?: StringWithAggregatesFilter<"Area"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Area"> | string | null
    active?: BoolWithAggregatesFilter<"Area"> | boolean
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    cedula?: StringFilter<"Employee"> | string
    nombres?: StringFilter<"Employee"> | string
    apellidos?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    telefono?: StringNullableFilter<"Employee"> | string | null
    direccion?: StringNullableFilter<"Employee"> | string | null
    cargo?: StringNullableFilter<"Employee"> | string | null
    fechaIngreso?: DateTimeNullableFilter<"Employee"> | Date | string | null
    estado?: StringFilter<"Employee"> | string
    notas?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    areaId?: IntFilter<"Employee"> | number
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    Penalties?: PenaltyListRelationFilter
    Convocations?: ConvocationEmployeeListRelationFilter
    Attendance?: AttendanceListRelationFilter
    AttendanceRec?: AttendanceRecordListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    fechaIngreso?: SortOrderInput | SortOrder
    estado?: SortOrder
    notas?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
    area?: AreaOrderByWithRelationInput
    Penalties?: PenaltyOrderByRelationAggregateInput
    Convocations?: ConvocationEmployeeOrderByRelationAggregateInput
    Attendance?: AttendanceOrderByRelationAggregateInput
    AttendanceRec?: AttendanceRecordOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cedula?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    nombres?: StringFilter<"Employee"> | string
    apellidos?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    telefono?: StringNullableFilter<"Employee"> | string | null
    direccion?: StringNullableFilter<"Employee"> | string | null
    cargo?: StringNullableFilter<"Employee"> | string | null
    fechaIngreso?: DateTimeNullableFilter<"Employee"> | Date | string | null
    estado?: StringFilter<"Employee"> | string
    notas?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    areaId?: IntFilter<"Employee"> | number
    area?: XOR<AreaScalarRelationFilter, AreaWhereInput>
    Penalties?: PenaltyListRelationFilter
    Convocations?: ConvocationEmployeeListRelationFilter
    Attendance?: AttendanceListRelationFilter
    AttendanceRec?: AttendanceRecordListRelationFilter
  }, "id" | "cedula">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    fechaIngreso?: SortOrderInput | SortOrder
    estado?: SortOrder
    notas?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    cedula?: StringWithAggregatesFilter<"Employee"> | string
    nombres?: StringWithAggregatesFilter<"Employee"> | string
    apellidos?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    cargo?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    fechaIngreso?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    estado?: StringWithAggregatesFilter<"Employee"> | string
    notas?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    areaId?: IntWithAggregatesFilter<"Employee"> | number
  }

  export type ConvocationWhereInput = {
    AND?: ConvocationWhereInput | ConvocationWhereInput[]
    OR?: ConvocationWhereInput[]
    NOT?: ConvocationWhereInput | ConvocationWhereInput[]
    id?: IntFilter<"Convocation"> | number
    titulo?: StringFilter<"Convocation"> | string
    descripcion?: StringNullableFilter<"Convocation"> | string | null
    fechaTrabajo?: DateTimeFilter<"Convocation"> | Date | string
    estado?: StringFilter<"Convocation"> | string
    creadoPorId?: IntFilter<"Convocation"> | number
    createdAt?: DateTimeFilter<"Convocation"> | Date | string
    creadoPor?: XOR<UserScalarRelationFilter, UserWhereInput>
    Employees?: ConvocationEmployeeListRelationFilter
    Attendance?: AttendanceRecordListRelationFilter
  }

  export type ConvocationOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaTrabajo?: SortOrder
    estado?: SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
    creadoPor?: UserOrderByWithRelationInput
    Employees?: ConvocationEmployeeOrderByRelationAggregateInput
    Attendance?: AttendanceRecordOrderByRelationAggregateInput
  }

  export type ConvocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConvocationWhereInput | ConvocationWhereInput[]
    OR?: ConvocationWhereInput[]
    NOT?: ConvocationWhereInput | ConvocationWhereInput[]
    titulo?: StringFilter<"Convocation"> | string
    descripcion?: StringNullableFilter<"Convocation"> | string | null
    fechaTrabajo?: DateTimeFilter<"Convocation"> | Date | string
    estado?: StringFilter<"Convocation"> | string
    creadoPorId?: IntFilter<"Convocation"> | number
    createdAt?: DateTimeFilter<"Convocation"> | Date | string
    creadoPor?: XOR<UserScalarRelationFilter, UserWhereInput>
    Employees?: ConvocationEmployeeListRelationFilter
    Attendance?: AttendanceRecordListRelationFilter
  }, "id">

  export type ConvocationOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaTrabajo?: SortOrder
    estado?: SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
    _count?: ConvocationCountOrderByAggregateInput
    _avg?: ConvocationAvgOrderByAggregateInput
    _max?: ConvocationMaxOrderByAggregateInput
    _min?: ConvocationMinOrderByAggregateInput
    _sum?: ConvocationSumOrderByAggregateInput
  }

  export type ConvocationScalarWhereWithAggregatesInput = {
    AND?: ConvocationScalarWhereWithAggregatesInput | ConvocationScalarWhereWithAggregatesInput[]
    OR?: ConvocationScalarWhereWithAggregatesInput[]
    NOT?: ConvocationScalarWhereWithAggregatesInput | ConvocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Convocation"> | number
    titulo?: StringWithAggregatesFilter<"Convocation"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Convocation"> | string | null
    fechaTrabajo?: DateTimeWithAggregatesFilter<"Convocation"> | Date | string
    estado?: StringWithAggregatesFilter<"Convocation"> | string
    creadoPorId?: IntWithAggregatesFilter<"Convocation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Convocation"> | Date | string
  }

  export type ConvocationEmployeeWhereInput = {
    AND?: ConvocationEmployeeWhereInput | ConvocationEmployeeWhereInput[]
    OR?: ConvocationEmployeeWhereInput[]
    NOT?: ConvocationEmployeeWhereInput | ConvocationEmployeeWhereInput[]
    id?: IntFilter<"ConvocationEmployee"> | number
    convocationId?: IntFilter<"ConvocationEmployee"> | number
    employeeId?: IntFilter<"ConvocationEmployee"> | number
    estado?: StringFilter<"ConvocationEmployee"> | string
    comentario?: StringNullableFilter<"ConvocationEmployee"> | string | null
    assignedAreaId?: IntNullableFilter<"ConvocationEmployee"> | number | null
    updatedAt?: DateTimeFilter<"ConvocationEmployee"> | Date | string
    convocation?: XOR<ConvocationScalarRelationFilter, ConvocationWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    assignedArea?: XOR<AreaNullableScalarRelationFilter, AreaWhereInput> | null
  }

  export type ConvocationEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    convocationId?: SortOrder
    employeeId?: SortOrder
    estado?: SortOrder
    comentario?: SortOrderInput | SortOrder
    assignedAreaId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    convocation?: ConvocationOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    assignedArea?: AreaOrderByWithRelationInput
  }

  export type ConvocationEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    convocationId_employeeId?: ConvocationEmployeeConvocationIdEmployeeIdCompoundUniqueInput
    AND?: ConvocationEmployeeWhereInput | ConvocationEmployeeWhereInput[]
    OR?: ConvocationEmployeeWhereInput[]
    NOT?: ConvocationEmployeeWhereInput | ConvocationEmployeeWhereInput[]
    convocationId?: IntFilter<"ConvocationEmployee"> | number
    employeeId?: IntFilter<"ConvocationEmployee"> | number
    estado?: StringFilter<"ConvocationEmployee"> | string
    comentario?: StringNullableFilter<"ConvocationEmployee"> | string | null
    assignedAreaId?: IntNullableFilter<"ConvocationEmployee"> | number | null
    updatedAt?: DateTimeFilter<"ConvocationEmployee"> | Date | string
    convocation?: XOR<ConvocationScalarRelationFilter, ConvocationWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    assignedArea?: XOR<AreaNullableScalarRelationFilter, AreaWhereInput> | null
  }, "id" | "convocationId_employeeId">

  export type ConvocationEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    convocationId?: SortOrder
    employeeId?: SortOrder
    estado?: SortOrder
    comentario?: SortOrderInput | SortOrder
    assignedAreaId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: ConvocationEmployeeCountOrderByAggregateInput
    _avg?: ConvocationEmployeeAvgOrderByAggregateInput
    _max?: ConvocationEmployeeMaxOrderByAggregateInput
    _min?: ConvocationEmployeeMinOrderByAggregateInput
    _sum?: ConvocationEmployeeSumOrderByAggregateInput
  }

  export type ConvocationEmployeeScalarWhereWithAggregatesInput = {
    AND?: ConvocationEmployeeScalarWhereWithAggregatesInput | ConvocationEmployeeScalarWhereWithAggregatesInput[]
    OR?: ConvocationEmployeeScalarWhereWithAggregatesInput[]
    NOT?: ConvocationEmployeeScalarWhereWithAggregatesInput | ConvocationEmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConvocationEmployee"> | number
    convocationId?: IntWithAggregatesFilter<"ConvocationEmployee"> | number
    employeeId?: IntWithAggregatesFilter<"ConvocationEmployee"> | number
    estado?: StringWithAggregatesFilter<"ConvocationEmployee"> | string
    comentario?: StringNullableWithAggregatesFilter<"ConvocationEmployee"> | string | null
    assignedAreaId?: IntNullableWithAggregatesFilter<"ConvocationEmployee"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"ConvocationEmployee"> | Date | string
  }

  export type PenaltyWhereInput = {
    AND?: PenaltyWhereInput | PenaltyWhereInput[]
    OR?: PenaltyWhereInput[]
    NOT?: PenaltyWhereInput | PenaltyWhereInput[]
    id?: IntFilter<"Penalty"> | number
    employeeId?: IntFilter<"Penalty"> | number
    motivo?: StringFilter<"Penalty"> | string
    fechaInicio?: DateTimeFilter<"Penalty"> | Date | string
    fechaFin?: DateTimeFilter<"Penalty"> | Date | string
    origen?: StringFilter<"Penalty"> | string
    activo?: BoolFilter<"Penalty"> | boolean
    registradoPor?: IntNullableFilter<"Penalty"> | number | null
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type PenaltyOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    motivo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    origen?: SortOrder
    activo?: SortOrder
    registradoPor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PenaltyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PenaltyWhereInput | PenaltyWhereInput[]
    OR?: PenaltyWhereInput[]
    NOT?: PenaltyWhereInput | PenaltyWhereInput[]
    employeeId?: IntFilter<"Penalty"> | number
    motivo?: StringFilter<"Penalty"> | string
    fechaInicio?: DateTimeFilter<"Penalty"> | Date | string
    fechaFin?: DateTimeFilter<"Penalty"> | Date | string
    origen?: StringFilter<"Penalty"> | string
    activo?: BoolFilter<"Penalty"> | boolean
    registradoPor?: IntNullableFilter<"Penalty"> | number | null
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PenaltyOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    motivo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    origen?: SortOrder
    activo?: SortOrder
    registradoPor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PenaltyCountOrderByAggregateInput
    _avg?: PenaltyAvgOrderByAggregateInput
    _max?: PenaltyMaxOrderByAggregateInput
    _min?: PenaltyMinOrderByAggregateInput
    _sum?: PenaltySumOrderByAggregateInput
  }

  export type PenaltyScalarWhereWithAggregatesInput = {
    AND?: PenaltyScalarWhereWithAggregatesInput | PenaltyScalarWhereWithAggregatesInput[]
    OR?: PenaltyScalarWhereWithAggregatesInput[]
    NOT?: PenaltyScalarWhereWithAggregatesInput | PenaltyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Penalty"> | number
    employeeId?: IntWithAggregatesFilter<"Penalty"> | number
    motivo?: StringWithAggregatesFilter<"Penalty"> | string
    fechaInicio?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
    fechaFin?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
    origen?: StringWithAggregatesFilter<"Penalty"> | string
    activo?: BoolWithAggregatesFilter<"Penalty"> | boolean
    registradoPor?: IntNullableWithAggregatesFilter<"Penalty"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Penalty"> | Date | string
  }

  export type ParamWhereInput = {
    AND?: ParamWhereInput | ParamWhereInput[]
    OR?: ParamWhereInput[]
    NOT?: ParamWhereInput | ParamWhereInput[]
    clave?: StringFilter<"Param"> | string
    valor?: StringFilter<"Param"> | string
  }

  export type ParamOrderByWithRelationInput = {
    clave?: SortOrder
    valor?: SortOrder
  }

  export type ParamWhereUniqueInput = Prisma.AtLeast<{
    clave?: string
    AND?: ParamWhereInput | ParamWhereInput[]
    OR?: ParamWhereInput[]
    NOT?: ParamWhereInput | ParamWhereInput[]
    valor?: StringFilter<"Param"> | string
  }, "clave">

  export type ParamOrderByWithAggregationInput = {
    clave?: SortOrder
    valor?: SortOrder
    _count?: ParamCountOrderByAggregateInput
    _max?: ParamMaxOrderByAggregateInput
    _min?: ParamMinOrderByAggregateInput
  }

  export type ParamScalarWhereWithAggregatesInput = {
    AND?: ParamScalarWhereWithAggregatesInput | ParamScalarWhereWithAggregatesInput[]
    OR?: ParamScalarWhereWithAggregatesInput[]
    NOT?: ParamScalarWhereWithAggregatesInput | ParamScalarWhereWithAggregatesInput[]
    clave?: StringWithAggregatesFilter<"Param"> | string
    valor?: StringWithAggregatesFilter<"Param"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    actorUserId?: IntNullableFilter<"AuditLog"> | number | null
    accion?: StringFilter<"AuditLog"> | string
    entidad?: StringFilter<"AuditLog"> | string
    entidadId?: IntNullableFilter<"AuditLog"> | number | null
    payloadJson?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrderInput | SortOrder
    payloadJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorUserId?: IntNullableFilter<"AuditLog"> | number | null
    accion?: StringFilter<"AuditLog"> | string
    entidad?: StringFilter<"AuditLog"> | string
    entidadId?: IntNullableFilter<"AuditLog"> | number | null
    payloadJson?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorUserId?: SortOrderInput | SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrderInput | SortOrder
    payloadJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    actorUserId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    accion?: StringWithAggregatesFilter<"AuditLog"> | string
    entidad?: StringWithAggregatesFilter<"AuditLog"> | string
    entidadId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    payloadJson?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: IntFilter<"Attendance"> | number
    employeeId?: IntFilter<"Attendance"> | number
    fecha?: DateTimeFilter<"Attendance"> | Date | string
    horaEntrada?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    horaSalida?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrderInput | SortOrder
    horaSalida?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_fecha?: AttendanceEmployeeIdFechaCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    employeeId?: IntFilter<"Attendance"> | number
    fecha?: DateTimeFilter<"Attendance"> | Date | string
    horaEntrada?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    horaSalida?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_fecha">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrderInput | SortOrder
    horaSalida?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Attendance"> | number
    employeeId?: IntWithAggregatesFilter<"Attendance"> | number
    fecha?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    horaEntrada?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    horaSalida?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type AttendanceRecordWhereInput = {
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    id?: IntFilter<"AttendanceRecord"> | number
    employeeId?: IntFilter<"AttendanceRecord"> | number
    convocationId?: IntFilter<"AttendanceRecord"> | number
    fecha?: DateTimeFilter<"AttendanceRecord"> | Date | string
    horaEntrada?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    horaSalida?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    estado?: StringFilter<"AttendanceRecord"> | string
    comentario?: StringNullableFilter<"AttendanceRecord"> | string | null
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    convocation?: XOR<ConvocationScalarRelationFilter, ConvocationWhereInput>
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    convocationId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrderInput | SortOrder
    horaSalida?: SortOrderInput | SortOrder
    estado?: SortOrder
    comentario?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    convocation?: ConvocationOrderByWithRelationInput
  }

  export type AttendanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_convocationId?: AttendanceRecordEmployeeIdConvocationIdCompoundUniqueInput
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    employeeId?: IntFilter<"AttendanceRecord"> | number
    convocationId?: IntFilter<"AttendanceRecord"> | number
    fecha?: DateTimeFilter<"AttendanceRecord"> | Date | string
    horaEntrada?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    horaSalida?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    estado?: StringFilter<"AttendanceRecord"> | string
    comentario?: StringNullableFilter<"AttendanceRecord"> | string | null
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    convocation?: XOR<ConvocationScalarRelationFilter, ConvocationWhereInput>
  }, "id" | "employeeId_convocationId">

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    convocationId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrderInput | SortOrder
    horaSalida?: SortOrderInput | SortOrder
    estado?: SortOrder
    comentario?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _avg?: AttendanceRecordAvgOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
    _sum?: AttendanceRecordSumOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    OR?: AttendanceRecordScalarWhereWithAggregatesInput[]
    NOT?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    employeeId?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    convocationId?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    fecha?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    horaEntrada?: DateTimeNullableWithAggregatesFilter<"AttendanceRecord"> | Date | string | null
    horaSalida?: DateTimeNullableWithAggregatesFilter<"AttendanceRecord"> | Date | string | null
    estado?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    comentario?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    email?: string | null
    role?: string
    avatarPath?: string | null
    active?: boolean
    createdAt?: Date | string
    Convocations?: ConvocationCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    email?: string | null
    role?: string
    avatarPath?: string | null
    active?: boolean
    createdAt?: Date | string
    Convocations?: ConvocationUncheckedCreateNestedManyWithoutCreadoPorInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Convocations?: ConvocationUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Convocations?: ConvocationUncheckedUpdateManyWithoutCreadoPorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    email?: string | null
    role?: string
    avatarPath?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaCreateInput = {
    nombre: string
    descripcion?: string | null
    active?: boolean
    Empleados?: EmployeeCreateNestedManyWithoutAreaInput
    ConvocationAssigned?: ConvocationEmployeeCreateNestedManyWithoutAssignedAreaInput
  }

  export type AreaUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    active?: boolean
    Empleados?: EmployeeUncheckedCreateNestedManyWithoutAreaInput
    ConvocationAssigned?: ConvocationEmployeeUncheckedCreateNestedManyWithoutAssignedAreaInput
  }

  export type AreaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    Empleados?: EmployeeUpdateManyWithoutAreaNestedInput
    ConvocationAssigned?: ConvocationEmployeeUpdateManyWithoutAssignedAreaNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    Empleados?: EmployeeUncheckedUpdateManyWithoutAreaNestedInput
    ConvocationAssigned?: ConvocationEmployeeUncheckedUpdateManyWithoutAssignedAreaNestedInput
  }

  export type AreaCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    active?: boolean
  }

  export type AreaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeCreateInput = {
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    area: AreaCreateNestedOneWithoutEmpleadosInput
    Penalties?: PenaltyCreateNestedManyWithoutEmployeeInput
    Convocations?: ConvocationEmployeeCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    areaId: number
    Penalties?: PenaltyUncheckedCreateNestedManyWithoutEmployeeInput
    Convocations?: ConvocationEmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaUpdateOneRequiredWithoutEmpleadosNestedInput
    Penalties?: PenaltyUpdateManyWithoutEmployeeNestedInput
    Convocations?: ConvocationEmployeeUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    Penalties?: PenaltyUncheckedUpdateManyWithoutEmployeeNestedInput
    Convocations?: ConvocationEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    areaId: number
  }

  export type EmployeeUpdateManyMutationInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type ConvocationCreateInput = {
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    createdAt?: Date | string
    creadoPor: UserCreateNestedOneWithoutConvocationsInput
    Employees?: ConvocationEmployeeCreateNestedManyWithoutConvocationInput
    Attendance?: AttendanceRecordCreateNestedManyWithoutConvocationInput
  }

  export type ConvocationUncheckedCreateInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    creadoPorId: number
    createdAt?: Date | string
    Employees?: ConvocationEmployeeUncheckedCreateNestedManyWithoutConvocationInput
    Attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutConvocationInput
  }

  export type ConvocationUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UserUpdateOneRequiredWithoutConvocationsNestedInput
    Employees?: ConvocationEmployeeUpdateManyWithoutConvocationNestedInput
    Attendance?: AttendanceRecordUpdateManyWithoutConvocationNestedInput
  }

  export type ConvocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    creadoPorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employees?: ConvocationEmployeeUncheckedUpdateManyWithoutConvocationNestedInput
    Attendance?: AttendanceRecordUncheckedUpdateManyWithoutConvocationNestedInput
  }

  export type ConvocationCreateManyInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    creadoPorId: number
    createdAt?: Date | string
  }

  export type ConvocationUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    creadoPorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeCreateInput = {
    estado?: string
    comentario?: string | null
    updatedAt?: Date | string
    convocation: ConvocationCreateNestedOneWithoutEmployeesInput
    employee: EmployeeCreateNestedOneWithoutConvocationsInput
    assignedArea?: AreaCreateNestedOneWithoutConvocationAssignedInput
  }

  export type ConvocationEmployeeUncheckedCreateInput = {
    id?: number
    convocationId: number
    employeeId: number
    estado?: string
    comentario?: string | null
    assignedAreaId?: number | null
    updatedAt?: Date | string
  }

  export type ConvocationEmployeeUpdateInput = {
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convocation?: ConvocationUpdateOneRequiredWithoutEmployeesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutConvocationsNestedInput
    assignedArea?: AreaUpdateOneWithoutConvocationAssignedNestedInput
  }

  export type ConvocationEmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAreaId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeCreateManyInput = {
    id?: number
    convocationId: number
    employeeId: number
    estado?: string
    comentario?: string | null
    assignedAreaId?: number | null
    updatedAt?: Date | string
  }

  export type ConvocationEmployeeUpdateManyMutationInput = {
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAreaId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateInput = {
    motivo: string
    fechaInicio: Date | string
    fechaFin: Date | string
    origen?: string
    activo?: boolean
    registradoPor?: number | null
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPenaltiesInput
  }

  export type PenaltyUncheckedCreateInput = {
    id?: number
    employeeId: number
    motivo: string
    fechaInicio: Date | string
    fechaFin: Date | string
    origen?: string
    activo?: boolean
    registradoPor?: number | null
    createdAt?: Date | string
  }

  export type PenaltyUpdateInput = {
    motivo?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    origen?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    registradoPor?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPenaltiesNestedInput
  }

  export type PenaltyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    origen?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    registradoPor?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateManyInput = {
    id?: number
    employeeId: number
    motivo: string
    fechaInicio: Date | string
    fechaFin: Date | string
    origen?: string
    activo?: boolean
    registradoPor?: number | null
    createdAt?: Date | string
  }

  export type PenaltyUpdateManyMutationInput = {
    motivo?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    origen?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    registradoPor?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    origen?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    registradoPor?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParamCreateInput = {
    clave: string
    valor: string
  }

  export type ParamUncheckedCreateInput = {
    clave: string
    valor: string
  }

  export type ParamUpdateInput = {
    clave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
  }

  export type ParamUncheckedUpdateInput = {
    clave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
  }

  export type ParamCreateManyInput = {
    clave: string
    valor: string
  }

  export type ParamUpdateManyMutationInput = {
    clave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
  }

  export type ParamUncheckedUpdateManyInput = {
    clave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    actorUserId?: number | null
    accion: string
    entidad: string
    entidadId?: number | null
    payloadJson?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    actorUserId?: number | null
    accion: string
    entidad: string
    entidadId?: number | null
    payloadJson?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    actorUserId?: NullableIntFieldUpdateOperationsInput | number | null
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableIntFieldUpdateOperationsInput | number | null
    payloadJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorUserId?: NullableIntFieldUpdateOperationsInput | number | null
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableIntFieldUpdateOperationsInput | number | null
    payloadJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    actorUserId?: number | null
    accion: string
    entidad: string
    entidadId?: number | null
    payloadJson?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    actorUserId?: NullableIntFieldUpdateOperationsInput | number | null
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableIntFieldUpdateOperationsInput | number | null
    payloadJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorUserId?: NullableIntFieldUpdateOperationsInput | number | null
    accion?: StringFieldUpdateOperationsInput | string
    entidad?: StringFieldUpdateOperationsInput | string
    entidadId?: NullableIntFieldUpdateOperationsInput | number | null
    payloadJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: number
    employeeId: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: number
    employeeId: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateInput = {
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendanceRecInput
    convocation: ConvocationCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: number
    employeeId: number
    convocationId: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceRecNestedInput
    convocation?: ConvocationUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateManyInput = {
    id?: number
    employeeId: number
    convocationId: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ConvocationListRelationFilter = {
    every?: ConvocationWhereInput
    some?: ConvocationWhereInput
    none?: ConvocationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConvocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    avatarPath?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    avatarPath?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    avatarPath?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type ConvocationEmployeeListRelationFilter = {
    every?: ConvocationEmployeeWhereInput
    some?: ConvocationEmployeeWhereInput
    none?: ConvocationEmployeeWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConvocationEmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    active?: SortOrder
  }

  export type AreaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    active?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    active?: SortOrder
  }

  export type AreaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AreaScalarRelationFilter = {
    is?: AreaWhereInput
    isNot?: AreaWhereInput
  }

  export type PenaltyListRelationFilter = {
    every?: PenaltyWhereInput
    some?: PenaltyWhereInput
    none?: PenaltyWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type PenaltyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    cargo?: SortOrder
    fechaIngreso?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    cargo?: SortOrder
    fechaIngreso?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    nombres?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    cargo?: SortOrder
    fechaIngreso?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    areaId?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    areaId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ConvocationCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaTrabajo?: SortOrder
    estado?: SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConvocationAvgOrderByAggregateInput = {
    id?: SortOrder
    creadoPorId?: SortOrder
  }

  export type ConvocationMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaTrabajo?: SortOrder
    estado?: SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConvocationMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaTrabajo?: SortOrder
    estado?: SortOrder
    creadoPorId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConvocationSumOrderByAggregateInput = {
    id?: SortOrder
    creadoPorId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ConvocationScalarRelationFilter = {
    is?: ConvocationWhereInput
    isNot?: ConvocationWhereInput
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type AreaNullableScalarRelationFilter = {
    is?: AreaWhereInput | null
    isNot?: AreaWhereInput | null
  }

  export type ConvocationEmployeeConvocationIdEmployeeIdCompoundUniqueInput = {
    convocationId: number
    employeeId: number
  }

  export type ConvocationEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    convocationId?: SortOrder
    employeeId?: SortOrder
    estado?: SortOrder
    comentario?: SortOrder
    assignedAreaId?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConvocationEmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    convocationId?: SortOrder
    employeeId?: SortOrder
    assignedAreaId?: SortOrder
  }

  export type ConvocationEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    convocationId?: SortOrder
    employeeId?: SortOrder
    estado?: SortOrder
    comentario?: SortOrder
    assignedAreaId?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConvocationEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    convocationId?: SortOrder
    employeeId?: SortOrder
    estado?: SortOrder
    comentario?: SortOrder
    assignedAreaId?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConvocationEmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    convocationId?: SortOrder
    employeeId?: SortOrder
    assignedAreaId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PenaltyCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    motivo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    origen?: SortOrder
    activo?: SortOrder
    registradoPor?: SortOrder
    createdAt?: SortOrder
  }

  export type PenaltyAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    registradoPor?: SortOrder
  }

  export type PenaltyMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    motivo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    origen?: SortOrder
    activo?: SortOrder
    registradoPor?: SortOrder
    createdAt?: SortOrder
  }

  export type PenaltyMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    motivo?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    origen?: SortOrder
    activo?: SortOrder
    registradoPor?: SortOrder
    createdAt?: SortOrder
  }

  export type PenaltySumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    registradoPor?: SortOrder
  }

  export type ParamCountOrderByAggregateInput = {
    clave?: SortOrder
    valor?: SortOrder
  }

  export type ParamMaxOrderByAggregateInput = {
    clave?: SortOrder
    valor?: SortOrder
  }

  export type ParamMinOrderByAggregateInput = {
    clave?: SortOrder
    valor?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    payloadJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    entidadId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    payloadJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    accion?: SortOrder
    entidad?: SortOrder
    entidadId?: SortOrder
    payloadJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    actorUserId?: SortOrder
    entidadId?: SortOrder
  }

  export type AttendanceEmployeeIdFechaCompoundUniqueInput = {
    employeeId: number
    fecha: Date | string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrder
    horaSalida?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrder
    horaSalida?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrder
    horaSalida?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type AttendanceRecordEmployeeIdConvocationIdCompoundUniqueInput = {
    employeeId: number
    convocationId: number
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    convocationId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrder
    horaSalida?: SortOrder
    estado?: SortOrder
    comentario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    convocationId?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    convocationId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrder
    horaSalida?: SortOrder
    estado?: SortOrder
    comentario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    convocationId?: SortOrder
    fecha?: SortOrder
    horaEntrada?: SortOrder
    horaSalida?: SortOrder
    estado?: SortOrder
    comentario?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    convocationId?: SortOrder
  }

  export type ConvocationCreateNestedManyWithoutCreadoPorInput = {
    create?: XOR<ConvocationCreateWithoutCreadoPorInput, ConvocationUncheckedCreateWithoutCreadoPorInput> | ConvocationCreateWithoutCreadoPorInput[] | ConvocationUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: ConvocationCreateOrConnectWithoutCreadoPorInput | ConvocationCreateOrConnectWithoutCreadoPorInput[]
    createMany?: ConvocationCreateManyCreadoPorInputEnvelope
    connect?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
  }

  export type ConvocationUncheckedCreateNestedManyWithoutCreadoPorInput = {
    create?: XOR<ConvocationCreateWithoutCreadoPorInput, ConvocationUncheckedCreateWithoutCreadoPorInput> | ConvocationCreateWithoutCreadoPorInput[] | ConvocationUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: ConvocationCreateOrConnectWithoutCreadoPorInput | ConvocationCreateOrConnectWithoutCreadoPorInput[]
    createMany?: ConvocationCreateManyCreadoPorInputEnvelope
    connect?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ConvocationUpdateManyWithoutCreadoPorNestedInput = {
    create?: XOR<ConvocationCreateWithoutCreadoPorInput, ConvocationUncheckedCreateWithoutCreadoPorInput> | ConvocationCreateWithoutCreadoPorInput[] | ConvocationUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: ConvocationCreateOrConnectWithoutCreadoPorInput | ConvocationCreateOrConnectWithoutCreadoPorInput[]
    upsert?: ConvocationUpsertWithWhereUniqueWithoutCreadoPorInput | ConvocationUpsertWithWhereUniqueWithoutCreadoPorInput[]
    createMany?: ConvocationCreateManyCreadoPorInputEnvelope
    set?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
    disconnect?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
    delete?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
    connect?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
    update?: ConvocationUpdateWithWhereUniqueWithoutCreadoPorInput | ConvocationUpdateWithWhereUniqueWithoutCreadoPorInput[]
    updateMany?: ConvocationUpdateManyWithWhereWithoutCreadoPorInput | ConvocationUpdateManyWithWhereWithoutCreadoPorInput[]
    deleteMany?: ConvocationScalarWhereInput | ConvocationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConvocationUncheckedUpdateManyWithoutCreadoPorNestedInput = {
    create?: XOR<ConvocationCreateWithoutCreadoPorInput, ConvocationUncheckedCreateWithoutCreadoPorInput> | ConvocationCreateWithoutCreadoPorInput[] | ConvocationUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: ConvocationCreateOrConnectWithoutCreadoPorInput | ConvocationCreateOrConnectWithoutCreadoPorInput[]
    upsert?: ConvocationUpsertWithWhereUniqueWithoutCreadoPorInput | ConvocationUpsertWithWhereUniqueWithoutCreadoPorInput[]
    createMany?: ConvocationCreateManyCreadoPorInputEnvelope
    set?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
    disconnect?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
    delete?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
    connect?: ConvocationWhereUniqueInput | ConvocationWhereUniqueInput[]
    update?: ConvocationUpdateWithWhereUniqueWithoutCreadoPorInput | ConvocationUpdateWithWhereUniqueWithoutCreadoPorInput[]
    updateMany?: ConvocationUpdateManyWithWhereWithoutCreadoPorInput | ConvocationUpdateManyWithWhereWithoutCreadoPorInput[]
    deleteMany?: ConvocationScalarWhereInput | ConvocationScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutAreaInput = {
    create?: XOR<EmployeeCreateWithoutAreaInput, EmployeeUncheckedCreateWithoutAreaInput> | EmployeeCreateWithoutAreaInput[] | EmployeeUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutAreaInput | EmployeeCreateOrConnectWithoutAreaInput[]
    createMany?: EmployeeCreateManyAreaInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ConvocationEmployeeCreateNestedManyWithoutAssignedAreaInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutAssignedAreaInput, ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput> | ConvocationEmployeeCreateWithoutAssignedAreaInput[] | ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput | ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput[]
    createMany?: ConvocationEmployeeCreateManyAssignedAreaInputEnvelope
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<EmployeeCreateWithoutAreaInput, EmployeeUncheckedCreateWithoutAreaInput> | EmployeeCreateWithoutAreaInput[] | EmployeeUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutAreaInput | EmployeeCreateOrConnectWithoutAreaInput[]
    createMany?: EmployeeCreateManyAreaInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ConvocationEmployeeUncheckedCreateNestedManyWithoutAssignedAreaInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutAssignedAreaInput, ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput> | ConvocationEmployeeCreateWithoutAssignedAreaInput[] | ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput | ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput[]
    createMany?: ConvocationEmployeeCreateManyAssignedAreaInputEnvelope
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutAreaNestedInput = {
    create?: XOR<EmployeeCreateWithoutAreaInput, EmployeeUncheckedCreateWithoutAreaInput> | EmployeeCreateWithoutAreaInput[] | EmployeeUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutAreaInput | EmployeeCreateOrConnectWithoutAreaInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutAreaInput | EmployeeUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: EmployeeCreateManyAreaInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutAreaInput | EmployeeUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutAreaInput | EmployeeUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ConvocationEmployeeUpdateManyWithoutAssignedAreaNestedInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutAssignedAreaInput, ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput> | ConvocationEmployeeCreateWithoutAssignedAreaInput[] | ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput | ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput[]
    upsert?: ConvocationEmployeeUpsertWithWhereUniqueWithoutAssignedAreaInput | ConvocationEmployeeUpsertWithWhereUniqueWithoutAssignedAreaInput[]
    createMany?: ConvocationEmployeeCreateManyAssignedAreaInputEnvelope
    set?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    disconnect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    delete?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    update?: ConvocationEmployeeUpdateWithWhereUniqueWithoutAssignedAreaInput | ConvocationEmployeeUpdateWithWhereUniqueWithoutAssignedAreaInput[]
    updateMany?: ConvocationEmployeeUpdateManyWithWhereWithoutAssignedAreaInput | ConvocationEmployeeUpdateManyWithWhereWithoutAssignedAreaInput[]
    deleteMany?: ConvocationEmployeeScalarWhereInput | ConvocationEmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<EmployeeCreateWithoutAreaInput, EmployeeUncheckedCreateWithoutAreaInput> | EmployeeCreateWithoutAreaInput[] | EmployeeUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutAreaInput | EmployeeCreateOrConnectWithoutAreaInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutAreaInput | EmployeeUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: EmployeeCreateManyAreaInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutAreaInput | EmployeeUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutAreaInput | EmployeeUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ConvocationEmployeeUncheckedUpdateManyWithoutAssignedAreaNestedInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutAssignedAreaInput, ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput> | ConvocationEmployeeCreateWithoutAssignedAreaInput[] | ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput | ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput[]
    upsert?: ConvocationEmployeeUpsertWithWhereUniqueWithoutAssignedAreaInput | ConvocationEmployeeUpsertWithWhereUniqueWithoutAssignedAreaInput[]
    createMany?: ConvocationEmployeeCreateManyAssignedAreaInputEnvelope
    set?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    disconnect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    delete?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    update?: ConvocationEmployeeUpdateWithWhereUniqueWithoutAssignedAreaInput | ConvocationEmployeeUpdateWithWhereUniqueWithoutAssignedAreaInput[]
    updateMany?: ConvocationEmployeeUpdateManyWithWhereWithoutAssignedAreaInput | ConvocationEmployeeUpdateManyWithWhereWithoutAssignedAreaInput[]
    deleteMany?: ConvocationEmployeeScalarWhereInput | ConvocationEmployeeScalarWhereInput[]
  }

  export type AreaCreateNestedOneWithoutEmpleadosInput = {
    create?: XOR<AreaCreateWithoutEmpleadosInput, AreaUncheckedCreateWithoutEmpleadosInput>
    connectOrCreate?: AreaCreateOrConnectWithoutEmpleadosInput
    connect?: AreaWhereUniqueInput
  }

  export type PenaltyCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PenaltyCreateWithoutEmployeeInput, PenaltyUncheckedCreateWithoutEmployeeInput> | PenaltyCreateWithoutEmployeeInput[] | PenaltyUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutEmployeeInput | PenaltyCreateOrConnectWithoutEmployeeInput[]
    createMany?: PenaltyCreateManyEmployeeInputEnvelope
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
  }

  export type ConvocationEmployeeCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutEmployeeInput, ConvocationEmployeeUncheckedCreateWithoutEmployeeInput> | ConvocationEmployeeCreateWithoutEmployeeInput[] | ConvocationEmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutEmployeeInput | ConvocationEmployeeCreateOrConnectWithoutEmployeeInput[]
    createMany?: ConvocationEmployeeCreateManyEmployeeInputEnvelope
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput> | AttendanceRecordCreateWithoutEmployeeInput[] | AttendanceRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutEmployeeInput | AttendanceRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceRecordCreateManyEmployeeInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type PenaltyUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PenaltyCreateWithoutEmployeeInput, PenaltyUncheckedCreateWithoutEmployeeInput> | PenaltyCreateWithoutEmployeeInput[] | PenaltyUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutEmployeeInput | PenaltyCreateOrConnectWithoutEmployeeInput[]
    createMany?: PenaltyCreateManyEmployeeInputEnvelope
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
  }

  export type ConvocationEmployeeUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutEmployeeInput, ConvocationEmployeeUncheckedCreateWithoutEmployeeInput> | ConvocationEmployeeCreateWithoutEmployeeInput[] | ConvocationEmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutEmployeeInput | ConvocationEmployeeCreateOrConnectWithoutEmployeeInput[]
    createMany?: ConvocationEmployeeCreateManyEmployeeInputEnvelope
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput> | AttendanceRecordCreateWithoutEmployeeInput[] | AttendanceRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutEmployeeInput | AttendanceRecordCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceRecordCreateManyEmployeeInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AreaUpdateOneRequiredWithoutEmpleadosNestedInput = {
    create?: XOR<AreaCreateWithoutEmpleadosInput, AreaUncheckedCreateWithoutEmpleadosInput>
    connectOrCreate?: AreaCreateOrConnectWithoutEmpleadosInput
    upsert?: AreaUpsertWithoutEmpleadosInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutEmpleadosInput, AreaUpdateWithoutEmpleadosInput>, AreaUncheckedUpdateWithoutEmpleadosInput>
  }

  export type PenaltyUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PenaltyCreateWithoutEmployeeInput, PenaltyUncheckedCreateWithoutEmployeeInput> | PenaltyCreateWithoutEmployeeInput[] | PenaltyUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutEmployeeInput | PenaltyCreateOrConnectWithoutEmployeeInput[]
    upsert?: PenaltyUpsertWithWhereUniqueWithoutEmployeeInput | PenaltyUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PenaltyCreateManyEmployeeInputEnvelope
    set?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    disconnect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    delete?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    update?: PenaltyUpdateWithWhereUniqueWithoutEmployeeInput | PenaltyUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PenaltyUpdateManyWithWhereWithoutEmployeeInput | PenaltyUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
  }

  export type ConvocationEmployeeUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutEmployeeInput, ConvocationEmployeeUncheckedCreateWithoutEmployeeInput> | ConvocationEmployeeCreateWithoutEmployeeInput[] | ConvocationEmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutEmployeeInput | ConvocationEmployeeCreateOrConnectWithoutEmployeeInput[]
    upsert?: ConvocationEmployeeUpsertWithWhereUniqueWithoutEmployeeInput | ConvocationEmployeeUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ConvocationEmployeeCreateManyEmployeeInputEnvelope
    set?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    disconnect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    delete?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    update?: ConvocationEmployeeUpdateWithWhereUniqueWithoutEmployeeInput | ConvocationEmployeeUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ConvocationEmployeeUpdateManyWithWhereWithoutEmployeeInput | ConvocationEmployeeUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ConvocationEmployeeScalarWhereInput | ConvocationEmployeeScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeeInput | AttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput> | AttendanceRecordCreateWithoutEmployeeInput[] | AttendanceRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutEmployeeInput | AttendanceRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceRecordCreateManyEmployeeInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput | AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type PenaltyUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PenaltyCreateWithoutEmployeeInput, PenaltyUncheckedCreateWithoutEmployeeInput> | PenaltyCreateWithoutEmployeeInput[] | PenaltyUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PenaltyCreateOrConnectWithoutEmployeeInput | PenaltyCreateOrConnectWithoutEmployeeInput[]
    upsert?: PenaltyUpsertWithWhereUniqueWithoutEmployeeInput | PenaltyUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PenaltyCreateManyEmployeeInputEnvelope
    set?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    disconnect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    delete?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    connect?: PenaltyWhereUniqueInput | PenaltyWhereUniqueInput[]
    update?: PenaltyUpdateWithWhereUniqueWithoutEmployeeInput | PenaltyUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PenaltyUpdateManyWithWhereWithoutEmployeeInput | PenaltyUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
  }

  export type ConvocationEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutEmployeeInput, ConvocationEmployeeUncheckedCreateWithoutEmployeeInput> | ConvocationEmployeeCreateWithoutEmployeeInput[] | ConvocationEmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutEmployeeInput | ConvocationEmployeeCreateOrConnectWithoutEmployeeInput[]
    upsert?: ConvocationEmployeeUpsertWithWhereUniqueWithoutEmployeeInput | ConvocationEmployeeUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ConvocationEmployeeCreateManyEmployeeInputEnvelope
    set?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    disconnect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    delete?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    update?: ConvocationEmployeeUpdateWithWhereUniqueWithoutEmployeeInput | ConvocationEmployeeUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ConvocationEmployeeUpdateManyWithWhereWithoutEmployeeInput | ConvocationEmployeeUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ConvocationEmployeeScalarWhereInput | ConvocationEmployeeScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeeInput | AttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput> | AttendanceRecordCreateWithoutEmployeeInput[] | AttendanceRecordUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutEmployeeInput | AttendanceRecordCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceRecordCreateManyEmployeeInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput | AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConvocationsInput = {
    create?: XOR<UserCreateWithoutConvocationsInput, UserUncheckedCreateWithoutConvocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConvocationsInput
    connect?: UserWhereUniqueInput
  }

  export type ConvocationEmployeeCreateNestedManyWithoutConvocationInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutConvocationInput, ConvocationEmployeeUncheckedCreateWithoutConvocationInput> | ConvocationEmployeeCreateWithoutConvocationInput[] | ConvocationEmployeeUncheckedCreateWithoutConvocationInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutConvocationInput | ConvocationEmployeeCreateOrConnectWithoutConvocationInput[]
    createMany?: ConvocationEmployeeCreateManyConvocationInputEnvelope
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutConvocationInput = {
    create?: XOR<AttendanceRecordCreateWithoutConvocationInput, AttendanceRecordUncheckedCreateWithoutConvocationInput> | AttendanceRecordCreateWithoutConvocationInput[] | AttendanceRecordUncheckedCreateWithoutConvocationInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutConvocationInput | AttendanceRecordCreateOrConnectWithoutConvocationInput[]
    createMany?: AttendanceRecordCreateManyConvocationInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type ConvocationEmployeeUncheckedCreateNestedManyWithoutConvocationInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutConvocationInput, ConvocationEmployeeUncheckedCreateWithoutConvocationInput> | ConvocationEmployeeCreateWithoutConvocationInput[] | ConvocationEmployeeUncheckedCreateWithoutConvocationInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutConvocationInput | ConvocationEmployeeCreateOrConnectWithoutConvocationInput[]
    createMany?: ConvocationEmployeeCreateManyConvocationInputEnvelope
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutConvocationInput = {
    create?: XOR<AttendanceRecordCreateWithoutConvocationInput, AttendanceRecordUncheckedCreateWithoutConvocationInput> | AttendanceRecordCreateWithoutConvocationInput[] | AttendanceRecordUncheckedCreateWithoutConvocationInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutConvocationInput | AttendanceRecordCreateOrConnectWithoutConvocationInput[]
    createMany?: AttendanceRecordCreateManyConvocationInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConvocationsNestedInput = {
    create?: XOR<UserCreateWithoutConvocationsInput, UserUncheckedCreateWithoutConvocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConvocationsInput
    upsert?: UserUpsertWithoutConvocationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConvocationsInput, UserUpdateWithoutConvocationsInput>, UserUncheckedUpdateWithoutConvocationsInput>
  }

  export type ConvocationEmployeeUpdateManyWithoutConvocationNestedInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutConvocationInput, ConvocationEmployeeUncheckedCreateWithoutConvocationInput> | ConvocationEmployeeCreateWithoutConvocationInput[] | ConvocationEmployeeUncheckedCreateWithoutConvocationInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutConvocationInput | ConvocationEmployeeCreateOrConnectWithoutConvocationInput[]
    upsert?: ConvocationEmployeeUpsertWithWhereUniqueWithoutConvocationInput | ConvocationEmployeeUpsertWithWhereUniqueWithoutConvocationInput[]
    createMany?: ConvocationEmployeeCreateManyConvocationInputEnvelope
    set?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    disconnect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    delete?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    update?: ConvocationEmployeeUpdateWithWhereUniqueWithoutConvocationInput | ConvocationEmployeeUpdateWithWhereUniqueWithoutConvocationInput[]
    updateMany?: ConvocationEmployeeUpdateManyWithWhereWithoutConvocationInput | ConvocationEmployeeUpdateManyWithWhereWithoutConvocationInput[]
    deleteMany?: ConvocationEmployeeScalarWhereInput | ConvocationEmployeeScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutConvocationNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutConvocationInput, AttendanceRecordUncheckedCreateWithoutConvocationInput> | AttendanceRecordCreateWithoutConvocationInput[] | AttendanceRecordUncheckedCreateWithoutConvocationInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutConvocationInput | AttendanceRecordCreateOrConnectWithoutConvocationInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutConvocationInput | AttendanceRecordUpsertWithWhereUniqueWithoutConvocationInput[]
    createMany?: AttendanceRecordCreateManyConvocationInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutConvocationInput | AttendanceRecordUpdateWithWhereUniqueWithoutConvocationInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutConvocationInput | AttendanceRecordUpdateManyWithWhereWithoutConvocationInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type ConvocationEmployeeUncheckedUpdateManyWithoutConvocationNestedInput = {
    create?: XOR<ConvocationEmployeeCreateWithoutConvocationInput, ConvocationEmployeeUncheckedCreateWithoutConvocationInput> | ConvocationEmployeeCreateWithoutConvocationInput[] | ConvocationEmployeeUncheckedCreateWithoutConvocationInput[]
    connectOrCreate?: ConvocationEmployeeCreateOrConnectWithoutConvocationInput | ConvocationEmployeeCreateOrConnectWithoutConvocationInput[]
    upsert?: ConvocationEmployeeUpsertWithWhereUniqueWithoutConvocationInput | ConvocationEmployeeUpsertWithWhereUniqueWithoutConvocationInput[]
    createMany?: ConvocationEmployeeCreateManyConvocationInputEnvelope
    set?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    disconnect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    delete?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    connect?: ConvocationEmployeeWhereUniqueInput | ConvocationEmployeeWhereUniqueInput[]
    update?: ConvocationEmployeeUpdateWithWhereUniqueWithoutConvocationInput | ConvocationEmployeeUpdateWithWhereUniqueWithoutConvocationInput[]
    updateMany?: ConvocationEmployeeUpdateManyWithWhereWithoutConvocationInput | ConvocationEmployeeUpdateManyWithWhereWithoutConvocationInput[]
    deleteMany?: ConvocationEmployeeScalarWhereInput | ConvocationEmployeeScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutConvocationNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutConvocationInput, AttendanceRecordUncheckedCreateWithoutConvocationInput> | AttendanceRecordCreateWithoutConvocationInput[] | AttendanceRecordUncheckedCreateWithoutConvocationInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutConvocationInput | AttendanceRecordCreateOrConnectWithoutConvocationInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutConvocationInput | AttendanceRecordUpsertWithWhereUniqueWithoutConvocationInput[]
    createMany?: AttendanceRecordCreateManyConvocationInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutConvocationInput | AttendanceRecordUpdateWithWhereUniqueWithoutConvocationInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutConvocationInput | AttendanceRecordUpdateManyWithWhereWithoutConvocationInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type ConvocationCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ConvocationCreateWithoutEmployeesInput, ConvocationUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ConvocationCreateOrConnectWithoutEmployeesInput
    connect?: ConvocationWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutConvocationsInput = {
    create?: XOR<EmployeeCreateWithoutConvocationsInput, EmployeeUncheckedCreateWithoutConvocationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutConvocationsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type AreaCreateNestedOneWithoutConvocationAssignedInput = {
    create?: XOR<AreaCreateWithoutConvocationAssignedInput, AreaUncheckedCreateWithoutConvocationAssignedInput>
    connectOrCreate?: AreaCreateOrConnectWithoutConvocationAssignedInput
    connect?: AreaWhereUniqueInput
  }

  export type ConvocationUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<ConvocationCreateWithoutEmployeesInput, ConvocationUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ConvocationCreateOrConnectWithoutEmployeesInput
    upsert?: ConvocationUpsertWithoutEmployeesInput
    connect?: ConvocationWhereUniqueInput
    update?: XOR<XOR<ConvocationUpdateToOneWithWhereWithoutEmployeesInput, ConvocationUpdateWithoutEmployeesInput>, ConvocationUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutConvocationsNestedInput = {
    create?: XOR<EmployeeCreateWithoutConvocationsInput, EmployeeUncheckedCreateWithoutConvocationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutConvocationsInput
    upsert?: EmployeeUpsertWithoutConvocationsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutConvocationsInput, EmployeeUpdateWithoutConvocationsInput>, EmployeeUncheckedUpdateWithoutConvocationsInput>
  }

  export type AreaUpdateOneWithoutConvocationAssignedNestedInput = {
    create?: XOR<AreaCreateWithoutConvocationAssignedInput, AreaUncheckedCreateWithoutConvocationAssignedInput>
    connectOrCreate?: AreaCreateOrConnectWithoutConvocationAssignedInput
    upsert?: AreaUpsertWithoutConvocationAssignedInput
    disconnect?: AreaWhereInput | boolean
    delete?: AreaWhereInput | boolean
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutConvocationAssignedInput, AreaUpdateWithoutConvocationAssignedInput>, AreaUncheckedUpdateWithoutConvocationAssignedInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeCreateNestedOneWithoutPenaltiesInput = {
    create?: XOR<EmployeeCreateWithoutPenaltiesInput, EmployeeUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPenaltiesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutPenaltiesNestedInput = {
    create?: XOR<EmployeeCreateWithoutPenaltiesInput, EmployeeUncheckedCreateWithoutPenaltiesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPenaltiesInput
    upsert?: EmployeeUpsertWithoutPenaltiesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPenaltiesInput, EmployeeUpdateWithoutPenaltiesInput>, EmployeeUncheckedUpdateWithoutPenaltiesInput>
  }

  export type EmployeeCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceInput
    upsert?: EmployeeUpsertWithoutAttendanceInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendanceInput, EmployeeUpdateWithoutAttendanceInput>, EmployeeUncheckedUpdateWithoutAttendanceInput>
  }

  export type EmployeeCreateNestedOneWithoutAttendanceRecInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceRecInput, EmployeeUncheckedCreateWithoutAttendanceRecInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceRecInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ConvocationCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<ConvocationCreateWithoutAttendanceInput, ConvocationUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ConvocationCreateOrConnectWithoutAttendanceInput
    connect?: ConvocationWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAttendanceRecNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceRecInput, EmployeeUncheckedCreateWithoutAttendanceRecInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceRecInput
    upsert?: EmployeeUpsertWithoutAttendanceRecInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendanceRecInput, EmployeeUpdateWithoutAttendanceRecInput>, EmployeeUncheckedUpdateWithoutAttendanceRecInput>
  }

  export type ConvocationUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<ConvocationCreateWithoutAttendanceInput, ConvocationUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ConvocationCreateOrConnectWithoutAttendanceInput
    upsert?: ConvocationUpsertWithoutAttendanceInput
    connect?: ConvocationWhereUniqueInput
    update?: XOR<XOR<ConvocationUpdateToOneWithWhereWithoutAttendanceInput, ConvocationUpdateWithoutAttendanceInput>, ConvocationUncheckedUpdateWithoutAttendanceInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ConvocationCreateWithoutCreadoPorInput = {
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    createdAt?: Date | string
    Employees?: ConvocationEmployeeCreateNestedManyWithoutConvocationInput
    Attendance?: AttendanceRecordCreateNestedManyWithoutConvocationInput
  }

  export type ConvocationUncheckedCreateWithoutCreadoPorInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    createdAt?: Date | string
    Employees?: ConvocationEmployeeUncheckedCreateNestedManyWithoutConvocationInput
    Attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutConvocationInput
  }

  export type ConvocationCreateOrConnectWithoutCreadoPorInput = {
    where: ConvocationWhereUniqueInput
    create: XOR<ConvocationCreateWithoutCreadoPorInput, ConvocationUncheckedCreateWithoutCreadoPorInput>
  }

  export type ConvocationCreateManyCreadoPorInputEnvelope = {
    data: ConvocationCreateManyCreadoPorInput | ConvocationCreateManyCreadoPorInput[]
  }

  export type ConvocationUpsertWithWhereUniqueWithoutCreadoPorInput = {
    where: ConvocationWhereUniqueInput
    update: XOR<ConvocationUpdateWithoutCreadoPorInput, ConvocationUncheckedUpdateWithoutCreadoPorInput>
    create: XOR<ConvocationCreateWithoutCreadoPorInput, ConvocationUncheckedCreateWithoutCreadoPorInput>
  }

  export type ConvocationUpdateWithWhereUniqueWithoutCreadoPorInput = {
    where: ConvocationWhereUniqueInput
    data: XOR<ConvocationUpdateWithoutCreadoPorInput, ConvocationUncheckedUpdateWithoutCreadoPorInput>
  }

  export type ConvocationUpdateManyWithWhereWithoutCreadoPorInput = {
    where: ConvocationScalarWhereInput
    data: XOR<ConvocationUpdateManyMutationInput, ConvocationUncheckedUpdateManyWithoutCreadoPorInput>
  }

  export type ConvocationScalarWhereInput = {
    AND?: ConvocationScalarWhereInput | ConvocationScalarWhereInput[]
    OR?: ConvocationScalarWhereInput[]
    NOT?: ConvocationScalarWhereInput | ConvocationScalarWhereInput[]
    id?: IntFilter<"Convocation"> | number
    titulo?: StringFilter<"Convocation"> | string
    descripcion?: StringNullableFilter<"Convocation"> | string | null
    fechaTrabajo?: DateTimeFilter<"Convocation"> | Date | string
    estado?: StringFilter<"Convocation"> | string
    creadoPorId?: IntFilter<"Convocation"> | number
    createdAt?: DateTimeFilter<"Convocation"> | Date | string
  }

  export type EmployeeCreateWithoutAreaInput = {
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    Penalties?: PenaltyCreateNestedManyWithoutEmployeeInput
    Convocations?: ConvocationEmployeeCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAreaInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    Penalties?: PenaltyUncheckedCreateNestedManyWithoutEmployeeInput
    Convocations?: ConvocationEmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAreaInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAreaInput, EmployeeUncheckedCreateWithoutAreaInput>
  }

  export type EmployeeCreateManyAreaInputEnvelope = {
    data: EmployeeCreateManyAreaInput | EmployeeCreateManyAreaInput[]
  }

  export type ConvocationEmployeeCreateWithoutAssignedAreaInput = {
    estado?: string
    comentario?: string | null
    updatedAt?: Date | string
    convocation: ConvocationCreateNestedOneWithoutEmployeesInput
    employee: EmployeeCreateNestedOneWithoutConvocationsInput
  }

  export type ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput = {
    id?: number
    convocationId: number
    employeeId: number
    estado?: string
    comentario?: string | null
    updatedAt?: Date | string
  }

  export type ConvocationEmployeeCreateOrConnectWithoutAssignedAreaInput = {
    where: ConvocationEmployeeWhereUniqueInput
    create: XOR<ConvocationEmployeeCreateWithoutAssignedAreaInput, ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput>
  }

  export type ConvocationEmployeeCreateManyAssignedAreaInputEnvelope = {
    data: ConvocationEmployeeCreateManyAssignedAreaInput | ConvocationEmployeeCreateManyAssignedAreaInput[]
  }

  export type EmployeeUpsertWithWhereUniqueWithoutAreaInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutAreaInput, EmployeeUncheckedUpdateWithoutAreaInput>
    create: XOR<EmployeeCreateWithoutAreaInput, EmployeeUncheckedCreateWithoutAreaInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutAreaInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutAreaInput, EmployeeUncheckedUpdateWithoutAreaInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutAreaInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutAreaInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: IntFilter<"Employee"> | number
    cedula?: StringFilter<"Employee"> | string
    nombres?: StringFilter<"Employee"> | string
    apellidos?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    telefono?: StringNullableFilter<"Employee"> | string | null
    direccion?: StringNullableFilter<"Employee"> | string | null
    cargo?: StringNullableFilter<"Employee"> | string | null
    fechaIngreso?: DateTimeNullableFilter<"Employee"> | Date | string | null
    estado?: StringFilter<"Employee"> | string
    notas?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    areaId?: IntFilter<"Employee"> | number
  }

  export type ConvocationEmployeeUpsertWithWhereUniqueWithoutAssignedAreaInput = {
    where: ConvocationEmployeeWhereUniqueInput
    update: XOR<ConvocationEmployeeUpdateWithoutAssignedAreaInput, ConvocationEmployeeUncheckedUpdateWithoutAssignedAreaInput>
    create: XOR<ConvocationEmployeeCreateWithoutAssignedAreaInput, ConvocationEmployeeUncheckedCreateWithoutAssignedAreaInput>
  }

  export type ConvocationEmployeeUpdateWithWhereUniqueWithoutAssignedAreaInput = {
    where: ConvocationEmployeeWhereUniqueInput
    data: XOR<ConvocationEmployeeUpdateWithoutAssignedAreaInput, ConvocationEmployeeUncheckedUpdateWithoutAssignedAreaInput>
  }

  export type ConvocationEmployeeUpdateManyWithWhereWithoutAssignedAreaInput = {
    where: ConvocationEmployeeScalarWhereInput
    data: XOR<ConvocationEmployeeUpdateManyMutationInput, ConvocationEmployeeUncheckedUpdateManyWithoutAssignedAreaInput>
  }

  export type ConvocationEmployeeScalarWhereInput = {
    AND?: ConvocationEmployeeScalarWhereInput | ConvocationEmployeeScalarWhereInput[]
    OR?: ConvocationEmployeeScalarWhereInput[]
    NOT?: ConvocationEmployeeScalarWhereInput | ConvocationEmployeeScalarWhereInput[]
    id?: IntFilter<"ConvocationEmployee"> | number
    convocationId?: IntFilter<"ConvocationEmployee"> | number
    employeeId?: IntFilter<"ConvocationEmployee"> | number
    estado?: StringFilter<"ConvocationEmployee"> | string
    comentario?: StringNullableFilter<"ConvocationEmployee"> | string | null
    assignedAreaId?: IntNullableFilter<"ConvocationEmployee"> | number | null
    updatedAt?: DateTimeFilter<"ConvocationEmployee"> | Date | string
  }

  export type AreaCreateWithoutEmpleadosInput = {
    nombre: string
    descripcion?: string | null
    active?: boolean
    ConvocationAssigned?: ConvocationEmployeeCreateNestedManyWithoutAssignedAreaInput
  }

  export type AreaUncheckedCreateWithoutEmpleadosInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    active?: boolean
    ConvocationAssigned?: ConvocationEmployeeUncheckedCreateNestedManyWithoutAssignedAreaInput
  }

  export type AreaCreateOrConnectWithoutEmpleadosInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutEmpleadosInput, AreaUncheckedCreateWithoutEmpleadosInput>
  }

  export type PenaltyCreateWithoutEmployeeInput = {
    motivo: string
    fechaInicio: Date | string
    fechaFin: Date | string
    origen?: string
    activo?: boolean
    registradoPor?: number | null
    createdAt?: Date | string
  }

  export type PenaltyUncheckedCreateWithoutEmployeeInput = {
    id?: number
    motivo: string
    fechaInicio: Date | string
    fechaFin: Date | string
    origen?: string
    activo?: boolean
    registradoPor?: number | null
    createdAt?: Date | string
  }

  export type PenaltyCreateOrConnectWithoutEmployeeInput = {
    where: PenaltyWhereUniqueInput
    create: XOR<PenaltyCreateWithoutEmployeeInput, PenaltyUncheckedCreateWithoutEmployeeInput>
  }

  export type PenaltyCreateManyEmployeeInputEnvelope = {
    data: PenaltyCreateManyEmployeeInput | PenaltyCreateManyEmployeeInput[]
  }

  export type ConvocationEmployeeCreateWithoutEmployeeInput = {
    estado?: string
    comentario?: string | null
    updatedAt?: Date | string
    convocation: ConvocationCreateNestedOneWithoutEmployeesInput
    assignedArea?: AreaCreateNestedOneWithoutConvocationAssignedInput
  }

  export type ConvocationEmployeeUncheckedCreateWithoutEmployeeInput = {
    id?: number
    convocationId: number
    estado?: string
    comentario?: string | null
    assignedAreaId?: number | null
    updatedAt?: Date | string
  }

  export type ConvocationEmployeeCreateOrConnectWithoutEmployeeInput = {
    where: ConvocationEmployeeWhereUniqueInput
    create: XOR<ConvocationEmployeeCreateWithoutEmployeeInput, ConvocationEmployeeUncheckedCreateWithoutEmployeeInput>
  }

  export type ConvocationEmployeeCreateManyEmployeeInputEnvelope = {
    data: ConvocationEmployeeCreateManyEmployeeInput | ConvocationEmployeeCreateManyEmployeeInput[]
  }

  export type AttendanceCreateWithoutEmployeeInput = {
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceUncheckedCreateWithoutEmployeeInput = {
    id?: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceCreateManyEmployeeInputEnvelope = {
    data: AttendanceCreateManyEmployeeInput | AttendanceCreateManyEmployeeInput[]
  }

  export type AttendanceRecordCreateWithoutEmployeeInput = {
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    convocation: ConvocationCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceRecordUncheckedCreateWithoutEmployeeInput = {
    id?: number
    convocationId: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceRecordCreateManyEmployeeInputEnvelope = {
    data: AttendanceRecordCreateManyEmployeeInput | AttendanceRecordCreateManyEmployeeInput[]
  }

  export type AreaUpsertWithoutEmpleadosInput = {
    update: XOR<AreaUpdateWithoutEmpleadosInput, AreaUncheckedUpdateWithoutEmpleadosInput>
    create: XOR<AreaCreateWithoutEmpleadosInput, AreaUncheckedCreateWithoutEmpleadosInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutEmpleadosInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutEmpleadosInput, AreaUncheckedUpdateWithoutEmpleadosInput>
  }

  export type AreaUpdateWithoutEmpleadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    ConvocationAssigned?: ConvocationEmployeeUpdateManyWithoutAssignedAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutEmpleadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    ConvocationAssigned?: ConvocationEmployeeUncheckedUpdateManyWithoutAssignedAreaNestedInput
  }

  export type PenaltyUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PenaltyWhereUniqueInput
    update: XOR<PenaltyUpdateWithoutEmployeeInput, PenaltyUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PenaltyCreateWithoutEmployeeInput, PenaltyUncheckedCreateWithoutEmployeeInput>
  }

  export type PenaltyUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PenaltyWhereUniqueInput
    data: XOR<PenaltyUpdateWithoutEmployeeInput, PenaltyUncheckedUpdateWithoutEmployeeInput>
  }

  export type PenaltyUpdateManyWithWhereWithoutEmployeeInput = {
    where: PenaltyScalarWhereInput
    data: XOR<PenaltyUpdateManyMutationInput, PenaltyUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PenaltyScalarWhereInput = {
    AND?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
    OR?: PenaltyScalarWhereInput[]
    NOT?: PenaltyScalarWhereInput | PenaltyScalarWhereInput[]
    id?: IntFilter<"Penalty"> | number
    employeeId?: IntFilter<"Penalty"> | number
    motivo?: StringFilter<"Penalty"> | string
    fechaInicio?: DateTimeFilter<"Penalty"> | Date | string
    fechaFin?: DateTimeFilter<"Penalty"> | Date | string
    origen?: StringFilter<"Penalty"> | string
    activo?: BoolFilter<"Penalty"> | boolean
    registradoPor?: IntNullableFilter<"Penalty"> | number | null
    createdAt?: DateTimeFilter<"Penalty"> | Date | string
  }

  export type ConvocationEmployeeUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ConvocationEmployeeWhereUniqueInput
    update: XOR<ConvocationEmployeeUpdateWithoutEmployeeInput, ConvocationEmployeeUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ConvocationEmployeeCreateWithoutEmployeeInput, ConvocationEmployeeUncheckedCreateWithoutEmployeeInput>
  }

  export type ConvocationEmployeeUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ConvocationEmployeeWhereUniqueInput
    data: XOR<ConvocationEmployeeUpdateWithoutEmployeeInput, ConvocationEmployeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type ConvocationEmployeeUpdateManyWithWhereWithoutEmployeeInput = {
    where: ConvocationEmployeeScalarWhereInput
    data: XOR<ConvocationEmployeeUpdateManyMutationInput, ConvocationEmployeeUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: IntFilter<"Attendance"> | number
    employeeId?: IntFilter<"Attendance"> | number
    fecha?: DateTimeFilter<"Attendance"> | Date | string
    horaEntrada?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    horaSalida?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutEmployeeInput, AttendanceRecordUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceRecordCreateWithoutEmployeeInput, AttendanceRecordUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutEmployeeInput, AttendanceRecordUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    OR?: AttendanceRecordScalarWhereInput[]
    NOT?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    id?: IntFilter<"AttendanceRecord"> | number
    employeeId?: IntFilter<"AttendanceRecord"> | number
    convocationId?: IntFilter<"AttendanceRecord"> | number
    fecha?: DateTimeFilter<"AttendanceRecord"> | Date | string
    horaEntrada?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    horaSalida?: DateTimeNullableFilter<"AttendanceRecord"> | Date | string | null
    estado?: StringFilter<"AttendanceRecord"> | string
    comentario?: StringNullableFilter<"AttendanceRecord"> | string | null
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
  }

  export type UserCreateWithoutConvocationsInput = {
    username: string
    password: string
    email?: string | null
    role?: string
    avatarPath?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type UserUncheckedCreateWithoutConvocationsInput = {
    id?: number
    username: string
    password: string
    email?: string | null
    role?: string
    avatarPath?: string | null
    active?: boolean
    createdAt?: Date | string
  }

  export type UserCreateOrConnectWithoutConvocationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConvocationsInput, UserUncheckedCreateWithoutConvocationsInput>
  }

  export type ConvocationEmployeeCreateWithoutConvocationInput = {
    estado?: string
    comentario?: string | null
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutConvocationsInput
    assignedArea?: AreaCreateNestedOneWithoutConvocationAssignedInput
  }

  export type ConvocationEmployeeUncheckedCreateWithoutConvocationInput = {
    id?: number
    employeeId: number
    estado?: string
    comentario?: string | null
    assignedAreaId?: number | null
    updatedAt?: Date | string
  }

  export type ConvocationEmployeeCreateOrConnectWithoutConvocationInput = {
    where: ConvocationEmployeeWhereUniqueInput
    create: XOR<ConvocationEmployeeCreateWithoutConvocationInput, ConvocationEmployeeUncheckedCreateWithoutConvocationInput>
  }

  export type ConvocationEmployeeCreateManyConvocationInputEnvelope = {
    data: ConvocationEmployeeCreateManyConvocationInput | ConvocationEmployeeCreateManyConvocationInput[]
  }

  export type AttendanceRecordCreateWithoutConvocationInput = {
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendanceRecInput
  }

  export type AttendanceRecordUncheckedCreateWithoutConvocationInput = {
    id?: number
    employeeId: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateOrConnectWithoutConvocationInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutConvocationInput, AttendanceRecordUncheckedCreateWithoutConvocationInput>
  }

  export type AttendanceRecordCreateManyConvocationInputEnvelope = {
    data: AttendanceRecordCreateManyConvocationInput | AttendanceRecordCreateManyConvocationInput[]
  }

  export type UserUpsertWithoutConvocationsInput = {
    update: XOR<UserUpdateWithoutConvocationsInput, UserUncheckedUpdateWithoutConvocationsInput>
    create: XOR<UserCreateWithoutConvocationsInput, UserUncheckedCreateWithoutConvocationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConvocationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConvocationsInput, UserUncheckedUpdateWithoutConvocationsInput>
  }

  export type UserUpdateWithoutConvocationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutConvocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    avatarPath?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeUpsertWithWhereUniqueWithoutConvocationInput = {
    where: ConvocationEmployeeWhereUniqueInput
    update: XOR<ConvocationEmployeeUpdateWithoutConvocationInput, ConvocationEmployeeUncheckedUpdateWithoutConvocationInput>
    create: XOR<ConvocationEmployeeCreateWithoutConvocationInput, ConvocationEmployeeUncheckedCreateWithoutConvocationInput>
  }

  export type ConvocationEmployeeUpdateWithWhereUniqueWithoutConvocationInput = {
    where: ConvocationEmployeeWhereUniqueInput
    data: XOR<ConvocationEmployeeUpdateWithoutConvocationInput, ConvocationEmployeeUncheckedUpdateWithoutConvocationInput>
  }

  export type ConvocationEmployeeUpdateManyWithWhereWithoutConvocationInput = {
    where: ConvocationEmployeeScalarWhereInput
    data: XOR<ConvocationEmployeeUpdateManyMutationInput, ConvocationEmployeeUncheckedUpdateManyWithoutConvocationInput>
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutConvocationInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutConvocationInput, AttendanceRecordUncheckedUpdateWithoutConvocationInput>
    create: XOR<AttendanceRecordCreateWithoutConvocationInput, AttendanceRecordUncheckedCreateWithoutConvocationInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutConvocationInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutConvocationInput, AttendanceRecordUncheckedUpdateWithoutConvocationInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutConvocationInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutConvocationInput>
  }

  export type ConvocationCreateWithoutEmployeesInput = {
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    createdAt?: Date | string
    creadoPor: UserCreateNestedOneWithoutConvocationsInput
    Attendance?: AttendanceRecordCreateNestedManyWithoutConvocationInput
  }

  export type ConvocationUncheckedCreateWithoutEmployeesInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    creadoPorId: number
    createdAt?: Date | string
    Attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutConvocationInput
  }

  export type ConvocationCreateOrConnectWithoutEmployeesInput = {
    where: ConvocationWhereUniqueInput
    create: XOR<ConvocationCreateWithoutEmployeesInput, ConvocationUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeeCreateWithoutConvocationsInput = {
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    area: AreaCreateNestedOneWithoutEmpleadosInput
    Penalties?: PenaltyCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutConvocationsInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    areaId: number
    Penalties?: PenaltyUncheckedCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutConvocationsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutConvocationsInput, EmployeeUncheckedCreateWithoutConvocationsInput>
  }

  export type AreaCreateWithoutConvocationAssignedInput = {
    nombre: string
    descripcion?: string | null
    active?: boolean
    Empleados?: EmployeeCreateNestedManyWithoutAreaInput
  }

  export type AreaUncheckedCreateWithoutConvocationAssignedInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    active?: boolean
    Empleados?: EmployeeUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreaCreateOrConnectWithoutConvocationAssignedInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutConvocationAssignedInput, AreaUncheckedCreateWithoutConvocationAssignedInput>
  }

  export type ConvocationUpsertWithoutEmployeesInput = {
    update: XOR<ConvocationUpdateWithoutEmployeesInput, ConvocationUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ConvocationCreateWithoutEmployeesInput, ConvocationUncheckedCreateWithoutEmployeesInput>
    where?: ConvocationWhereInput
  }

  export type ConvocationUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ConvocationWhereInput
    data: XOR<ConvocationUpdateWithoutEmployeesInput, ConvocationUncheckedUpdateWithoutEmployeesInput>
  }

  export type ConvocationUpdateWithoutEmployeesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UserUpdateOneRequiredWithoutConvocationsNestedInput
    Attendance?: AttendanceRecordUpdateManyWithoutConvocationNestedInput
  }

  export type ConvocationUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    creadoPorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Attendance?: AttendanceRecordUncheckedUpdateManyWithoutConvocationNestedInput
  }

  export type EmployeeUpsertWithoutConvocationsInput = {
    update: XOR<EmployeeUpdateWithoutConvocationsInput, EmployeeUncheckedUpdateWithoutConvocationsInput>
    create: XOR<EmployeeCreateWithoutConvocationsInput, EmployeeUncheckedCreateWithoutConvocationsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutConvocationsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutConvocationsInput, EmployeeUncheckedUpdateWithoutConvocationsInput>
  }

  export type EmployeeUpdateWithoutConvocationsInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaUpdateOneRequiredWithoutEmpleadosNestedInput
    Penalties?: PenaltyUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutConvocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    Penalties?: PenaltyUncheckedUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type AreaUpsertWithoutConvocationAssignedInput = {
    update: XOR<AreaUpdateWithoutConvocationAssignedInput, AreaUncheckedUpdateWithoutConvocationAssignedInput>
    create: XOR<AreaCreateWithoutConvocationAssignedInput, AreaUncheckedCreateWithoutConvocationAssignedInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutConvocationAssignedInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutConvocationAssignedInput, AreaUncheckedUpdateWithoutConvocationAssignedInput>
  }

  export type AreaUpdateWithoutConvocationAssignedInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    Empleados?: EmployeeUpdateManyWithoutAreaNestedInput
  }

  export type AreaUncheckedUpdateWithoutConvocationAssignedInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    Empleados?: EmployeeUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type EmployeeCreateWithoutPenaltiesInput = {
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    area: AreaCreateNestedOneWithoutEmpleadosInput
    Convocations?: ConvocationEmployeeCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPenaltiesInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    areaId: number
    Convocations?: ConvocationEmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPenaltiesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPenaltiesInput, EmployeeUncheckedCreateWithoutPenaltiesInput>
  }

  export type EmployeeUpsertWithoutPenaltiesInput = {
    update: XOR<EmployeeUpdateWithoutPenaltiesInput, EmployeeUncheckedUpdateWithoutPenaltiesInput>
    create: XOR<EmployeeCreateWithoutPenaltiesInput, EmployeeUncheckedCreateWithoutPenaltiesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPenaltiesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPenaltiesInput, EmployeeUncheckedUpdateWithoutPenaltiesInput>
  }

  export type EmployeeUpdateWithoutPenaltiesInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaUpdateOneRequiredWithoutEmpleadosNestedInput
    Convocations?: ConvocationEmployeeUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPenaltiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    Convocations?: ConvocationEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAttendanceInput = {
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    area: AreaCreateNestedOneWithoutEmpleadosInput
    Penalties?: PenaltyCreateNestedManyWithoutEmployeeInput
    Convocations?: ConvocationEmployeeCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendanceInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    areaId: number
    Penalties?: PenaltyUncheckedCreateNestedManyWithoutEmployeeInput
    Convocations?: ConvocationEmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    AttendanceRec?: AttendanceRecordUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendanceInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
  }

  export type EmployeeUpsertWithoutAttendanceInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceInput, EmployeeUncheckedUpdateWithoutAttendanceInput>
    create: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendanceInput, EmployeeUncheckedUpdateWithoutAttendanceInput>
  }

  export type EmployeeUpdateWithoutAttendanceInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaUpdateOneRequiredWithoutEmpleadosNestedInput
    Penalties?: PenaltyUpdateManyWithoutEmployeeNestedInput
    Convocations?: ConvocationEmployeeUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    Penalties?: PenaltyUncheckedUpdateManyWithoutEmployeeNestedInput
    Convocations?: ConvocationEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutAttendanceRecInput = {
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    area: AreaCreateNestedOneWithoutEmpleadosInput
    Penalties?: PenaltyCreateNestedManyWithoutEmployeeInput
    Convocations?: ConvocationEmployeeCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendanceRecInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
    areaId: number
    Penalties?: PenaltyUncheckedCreateNestedManyWithoutEmployeeInput
    Convocations?: ConvocationEmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendanceRecInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceRecInput, EmployeeUncheckedCreateWithoutAttendanceRecInput>
  }

  export type ConvocationCreateWithoutAttendanceInput = {
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    createdAt?: Date | string
    creadoPor: UserCreateNestedOneWithoutConvocationsInput
    Employees?: ConvocationEmployeeCreateNestedManyWithoutConvocationInput
  }

  export type ConvocationUncheckedCreateWithoutAttendanceInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    creadoPorId: number
    createdAt?: Date | string
    Employees?: ConvocationEmployeeUncheckedCreateNestedManyWithoutConvocationInput
  }

  export type ConvocationCreateOrConnectWithoutAttendanceInput = {
    where: ConvocationWhereUniqueInput
    create: XOR<ConvocationCreateWithoutAttendanceInput, ConvocationUncheckedCreateWithoutAttendanceInput>
  }

  export type EmployeeUpsertWithoutAttendanceRecInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceRecInput, EmployeeUncheckedUpdateWithoutAttendanceRecInput>
    create: XOR<EmployeeCreateWithoutAttendanceRecInput, EmployeeUncheckedCreateWithoutAttendanceRecInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendanceRecInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendanceRecInput, EmployeeUncheckedUpdateWithoutAttendanceRecInput>
  }

  export type EmployeeUpdateWithoutAttendanceRecInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: AreaUpdateOneRequiredWithoutEmpleadosNestedInput
    Penalties?: PenaltyUpdateManyWithoutEmployeeNestedInput
    Convocations?: ConvocationEmployeeUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceRecInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    areaId?: IntFieldUpdateOperationsInput | number
    Penalties?: PenaltyUncheckedUpdateManyWithoutEmployeeNestedInput
    Convocations?: ConvocationEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ConvocationUpsertWithoutAttendanceInput = {
    update: XOR<ConvocationUpdateWithoutAttendanceInput, ConvocationUncheckedUpdateWithoutAttendanceInput>
    create: XOR<ConvocationCreateWithoutAttendanceInput, ConvocationUncheckedCreateWithoutAttendanceInput>
    where?: ConvocationWhereInput
  }

  export type ConvocationUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: ConvocationWhereInput
    data: XOR<ConvocationUpdateWithoutAttendanceInput, ConvocationUncheckedUpdateWithoutAttendanceInput>
  }

  export type ConvocationUpdateWithoutAttendanceInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UserUpdateOneRequiredWithoutConvocationsNestedInput
    Employees?: ConvocationEmployeeUpdateManyWithoutConvocationNestedInput
  }

  export type ConvocationUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    creadoPorId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employees?: ConvocationEmployeeUncheckedUpdateManyWithoutConvocationNestedInput
  }

  export type ConvocationCreateManyCreadoPorInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaTrabajo: Date | string
    estado?: string
    createdAt?: Date | string
  }

  export type ConvocationUpdateWithoutCreadoPorInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employees?: ConvocationEmployeeUpdateManyWithoutConvocationNestedInput
    Attendance?: AttendanceRecordUpdateManyWithoutConvocationNestedInput
  }

  export type ConvocationUncheckedUpdateWithoutCreadoPorInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employees?: ConvocationEmployeeUncheckedUpdateManyWithoutConvocationNestedInput
    Attendance?: AttendanceRecordUncheckedUpdateManyWithoutConvocationNestedInput
  }

  export type ConvocationUncheckedUpdateManyWithoutCreadoPorInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaTrabajo?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyAreaInput = {
    id?: number
    cedula: string
    nombres: string
    apellidos: string
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    cargo?: string | null
    fechaIngreso?: Date | string | null
    estado?: string
    notas?: string | null
    createdAt?: Date | string
  }

  export type ConvocationEmployeeCreateManyAssignedAreaInput = {
    id?: number
    convocationId: number
    employeeId: number
    estado?: string
    comentario?: string | null
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutAreaInput = {
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Penalties?: PenaltyUpdateManyWithoutEmployeeNestedInput
    Convocations?: ConvocationEmployeeUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Penalties?: PenaltyUncheckedUpdateManyWithoutEmployeeNestedInput
    Convocations?: ConvocationEmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    AttendanceRec?: AttendanceRecordUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedula?: StringFieldUpdateOperationsInput | string
    nombres?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    fechaIngreso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeUpdateWithoutAssignedAreaInput = {
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convocation?: ConvocationUpdateOneRequiredWithoutEmployeesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutConvocationsNestedInput
  }

  export type ConvocationEmployeeUncheckedUpdateWithoutAssignedAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeUncheckedUpdateManyWithoutAssignedAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyCreateManyEmployeeInput = {
    id?: number
    motivo: string
    fechaInicio: Date | string
    fechaFin: Date | string
    origen?: string
    activo?: boolean
    registradoPor?: number | null
    createdAt?: Date | string
  }

  export type ConvocationEmployeeCreateManyEmployeeInput = {
    id?: number
    convocationId: number
    estado?: string
    comentario?: string | null
    assignedAreaId?: number | null
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyEmployeeInput = {
    id?: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    createdAt?: Date | string
  }

  export type AttendanceRecordCreateManyEmployeeInput = {
    id?: number
    convocationId: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PenaltyUpdateWithoutEmployeeInput = {
    motivo?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    origen?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    registradoPor?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    origen?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    registradoPor?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PenaltyUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    motivo?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    origen?: StringFieldUpdateOperationsInput | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    registradoPor?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeUpdateWithoutEmployeeInput = {
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convocation?: ConvocationUpdateOneRequiredWithoutEmployeesNestedInput
    assignedArea?: AreaUpdateOneWithoutConvocationAssignedNestedInput
  }

  export type ConvocationEmployeeUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAreaId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAreaId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutEmployeeInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUpdateWithoutEmployeeInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    convocation?: ConvocationUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    convocationId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeCreateManyConvocationInput = {
    id?: number
    employeeId: number
    estado?: string
    comentario?: string | null
    assignedAreaId?: number | null
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateManyConvocationInput = {
    id?: number
    employeeId: number
    fecha: Date | string
    horaEntrada?: Date | string | null
    horaSalida?: Date | string | null
    estado?: string
    comentario?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConvocationEmployeeUpdateWithoutConvocationInput = {
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutConvocationsNestedInput
    assignedArea?: AreaUpdateOneWithoutConvocationAssignedNestedInput
  }

  export type ConvocationEmployeeUncheckedUpdateWithoutConvocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAreaId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocationEmployeeUncheckedUpdateManyWithoutConvocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAreaId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUpdateWithoutConvocationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceRecNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutConvocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutConvocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    horaEntrada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horaSalida?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}